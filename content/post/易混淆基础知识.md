+++
title = '易混淆基础知识'

description = "Meta"

tags = [ "Meta" ]

date = 2025-06-25T18:18:33+08:00
draft = true

+++

#### 数字代表几字节？

![](https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2025/06/69c93f14e2b99ebb8a7625591f786578.png)

A5有8位二进制，代表一个字节。内存的基本单位是字节，所以58-68之间有16字节，有16个A5这样的二进制数。

右边的58表示这个地址存放的数。

#### RVA与VA的转换

RVA=VA-ImageBase，VA是PE文件加载到内存后的内存地址，RVA是内存地址相对于其所在ImageBase的偏移量。

File Offset是数据在磁盘上原始PE文件中的字节偏移量，为什么和RVA不相等？

涉及到查找RVA所属的节，然后使用节的 `PointerToRawData` (文件偏移) 和 `VirtualAddress` (RVA) 字段进行计算。

因为PE文件加载到内存中，节与节之间会填充0。RVA只是相对于ImageBase的地址，而不是每一个节的数据相对于这个节起始地址的地址。

如果对于第一个节中的数据来说是相等的，但是被填充0之后RVA就包含了0和PE文件数据。

#### 大端序与小端序

大端序与小端序是同一个文本在计算机中的不同排列方式。

本质是因为计算机习惯从低位字节开始运算，而人类习惯从高位字节开始阅读。

例如对于一个16位的十六进制数值0x1234，高位字节是0x12，低位字节是0x34。

大端序表示为0x1234，小端序表示为0x3412。

平常在x64dbg中看到的都是小端序，因为x64dbg用于调试Windows系统的PE，而Intel CPU架构默认使用小端序(因为支持的是x86_64指令集)。

![](https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2025/06/3620fa8762675298cb4390e65d4a3686.png)

#### 汇编传参

汇编语言的传参方式是一个多层级的决策过程，由以下因素共同决定：**硬件层（体系结构）：** 提供可用的寄存器和指令集。**软件层（操作系统/ABI）：** 强制规定了跨模块和进程的函数调用标准。这是最重要的决定因素，因为所有代码都必须遵循它才能正确交互。**开发工具层（编程语言/编译器）：** 根据语言特性和优化策略，生成符合ABI的汇编代码

**Windows ABI (x64):**

- **整数/指针参数：** 优先级从左到右依次使用 `RCX`, `RDX`, `R8`, `R9`。超过4个的参数通过栈从右向左压入。
- **浮点参数：** 优先级从左到右依次使用 `XMM0`, `XMM1`, `XMM2`, `XMM3`。
- **返回值：** 整数/指针在 `RAX` 中，浮点在 `XMM0` 中。

**System V ABI (Linux, macOS, BSD for x64):**

- **整数/指针参数：** 优先级从左到右依次使用 `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`。超过6个的参数通过栈从右向左压入。
- **浮点参数：** 优先级从左到右依次使用 `XMM0` 到 `XMM7`。
- **返回值：** 整数/指针在 `RAX` 中，浮点在 `XMM0` 中。

尽管操作系统定义了ABI，但高级语言的编译器在生成汇编代码时，也会根据语言特性和优化级别来选择最合适的传参方式，以符合ABI。

- **调用约定（Calling Convention）：** 高级语言编译器（特别是C/C++）支持多种调用约定，这些约定会影响参数的传递方式和栈的清理责任。常见的有：
  - **`cdecl` (C Declaration):** 参数从右到左压栈，调用者清理栈。这是C语言在x86上的默认约定，支持可变参数函数。
  - **`stdcall` (Standard Call):** 参数从右到左压栈，被调用者清理栈。常用于Windows API函数。
  - **`fastcall`:** 尝试使用寄存器传递参数，其余参数压栈。具体使用哪些寄存器和数量因编译器和架构而异。
  - **`thiscall`:** C++成员函数默认约定，`this`指针通过特定寄存器（如x86上的`ECX`）或栈传递，其余参数类似`cdecl`或`stdcall`。
  - **`vectorcall` (Microsoft extension):** 针对SIMD/向量类型参数的优化，通过更多向量寄存器传递。

#### 寄存器寻址

![](https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2025/06/579b1fb2ac95218777dcb45dbb8b8580.png)

段寄存器一共有下面六种：

CS: 代码段寄存器，用于存放代码所在段的段基址

SS: 栈段寄存器，用于存放栈段的段基址

DS: 数据段寄存器，用户存放数据段的段基址

ES: 附加（数据）寄存器，用来存放程序使用的附加数据段的段基址

FS: 数据段寄存器，用来存放程序使用的附加数据段的段基址。它也用于计算SEH(结构化异常处理机制)，TEB（线程环境块），PEB（进程环境块）等地址

GS: 数据段寄存器，用来存放程序使用的附加数据段的段基址



`qword ptr ss:[rbp+0x18]`表示访问栈帧中 `rbp` 寄存器加上偏移量 `0x18` 处的一个8字节（quad word）的值。`ss` 段寄存器通常指向栈段，在x64下，`rbp` 寄存器通常作为帧指针，直接寻址栈上的局部变量或参数。当 `RSP` 或 `RBP` 用于**内存寻址**时，它们会**默认与 `SS` 段寄存器关联**，共同确定内存访问的上下文。这意味着通过 `RSP` 或 `RBP` 访问的内存地址被视为位于栈段中。

`qword ptr ds:[<GetSystemTimeAsFileTime>]`：这表示通过 `ds` 段寄存器（通常指向数据段）和 `<GetSystemTimeAsFileTime>` 符号的地址来调用函数。 `<GetSystemTimeAsFileTime>` 是一个外部函数的导入地址，它会通过IAT（Import Address Table）或动态解析的方式找到实际的函数入口点。



**默认段：** x86/x64指令集架构中，不同的内存寻址方式有**默认的段寄存器**。

- 使用 `RSP` 或 `RBP` 作为基址寄存器时，默认使用 `SS`（栈段）。
- 使用其他通用寄存器（如 `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`）作为基址寄存器时，以及**直接引用内存地址（如这里的 `<GetSystemTimeAsFileTime>`）时，默认使用 `DS`（数据段）**。



图中`mov rax, qword ptr ds:[0x7FF6424C2E18]`属于寄存器间接寻址。

`mov rax, qword ptr ds:[0x7FF6424C2E18]` 中的 `0x7FF6424C2E18` 是一个**固定的内存地址字面值**，所以它是直接寻址。

`ds:` 段前缀在这里的作用和之前解释的一样：在x64扁平内存模型下，它通常是冗余的（因为`DS`的基地址是0），或者仅仅是为了强调这个内存访问属于数据段的上下文。但无论有没有`ds:`，只要内存地址是一个硬编码的常量，它就是直接寻址。



在汇编语言中，`ptr` (pointer) 是一个**类型指示符（Type Specifier）\**或\**操作数大小指示符（Operand Size Specifier）**。它的主要作用是**明确指定内存操作数的大小（字节数）**。与C语言指针无关！

`ptr` 总是与一个大小关键字（如 `byte`, `word`, `dword`, `qword`, `xmmword` 等）一起使用。

1. **`byte ptr`：** 指示操作的内存大小是1字节（8位）。
2. **`word ptr`：** 指示操作的内存大小是2字节（16位）。
3. **`dword ptr`：** 指示操作的内存大小是4字节（32位）。
4. **`qword ptr`：** 指示操作的内存大小是8字节（64位）。



[rbx]和rbx，前者表示从rbx中存放的地址读取值，后者表示rbx的值。

出现XMM0~XMM3表示在对浮点寄存器进行操作。
